<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>7 Public-key encryption | Cryptography lecture notes</title>
  <meta name="description" content="7 Public-key encryption | Cryptography lecture notes" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="7 Public-key encryption | Cryptography lecture notes" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="7 Public-key encryption | Cryptography lecture notes" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="algebraic-structures.html"/>
<link rel="next" href="discrete-logarithm-cryptosystems.html"/>
<script src="libs/header-attrs-2.6/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="part"><span><b>I Introduction to modern cryptography</b></span></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Front page</a></li>
<li class="chapter" data-level="1" data-path="introduction-to-security.html"><a href="introduction-to-security.html"><i class="fa fa-check"></i><b>1</b> Introduction to security</a>
<ul>
<li class="chapter" data-level="1.1" data-path="introduction-to-security.html"><a href="introduction-to-security.html#what-cryptography-is-and-is-not"><i class="fa fa-check"></i><b>1.1</b> What cryptography is and is not</a></li>
<li class="chapter" data-level="1.2" data-path="introduction-to-security.html"><a href="introduction-to-security.html#fundamental-security-principles"><i class="fa fa-check"></i><b>1.2</b> Fundamental security principles</a></li>
<li class="chapter" data-level="1.3" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-parameter"><i class="fa fa-check"></i><b>1.3</b> Security parameter</a></li>
<li class="chapter" data-level="1.4" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-level"><i class="fa fa-check"></i><b>1.4</b> Security level</a></li>
</ul></li>
<li class="part"><span><b>II Symmetric cryptography</b></span></li>
<li class="chapter" data-level="2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html"><i class="fa fa-check"></i><b>2</b> Randomness in cryptography</a>
<ul>
<li class="chapter" data-level="2.1" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#one-time-pad"><i class="fa fa-check"></i><b>2.1</b> One-time pad</a></li>
<li class="chapter" data-level="2.2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:prngs"><i class="fa fa-check"></i><b>2.2</b> Pseudorandom generators</a></li>
<li class="chapter" data-level="2.3" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:examples"><i class="fa fa-check"></i><b>2.3</b> Linear feedback shift registers</a></li>
<li class="chapter" data-level="2.4" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#true-randomness"><i class="fa fa-check"></i><b>2.4</b> True randomness</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="block-ciphers.html"><a href="block-ciphers.html"><i class="fa fa-check"></i><b>3</b> Block ciphers</a>
<ul>
<li class="chapter" data-level="3.1" data-path="block-ciphers.html"><a href="block-ciphers.html#overview-of-block-ciphers"><i class="fa fa-check"></i><b>3.1</b> Overview of block ciphers</a></li>
<li class="chapter" data-level="3.2" data-path="block-ciphers.html"><a href="block-ciphers.html#modes-of-operation"><i class="fa fa-check"></i><b>3.2</b> Modes of operation</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="block-ciphers.html"><a href="block-ciphers.html#electronic-codebook-ecb-mode"><i class="fa fa-check"></i><b>3.2.1</b> Electronic codebook (ECB) mode</a></li>
<li class="chapter" data-level="3.2.2" data-path="block-ciphers.html"><a href="block-ciphers.html#cipher-block-chaining-cbc-mode"><i class="fa fa-check"></i><b>3.2.2</b> Cipher block chaining (CBC) mode</a></li>
<li class="chapter" data-level="3.2.3" data-path="block-ciphers.html"><a href="block-ciphers.html#output-feedback-ofb-mode"><i class="fa fa-check"></i><b>3.2.3</b> Output feedback (OFB) mode</a></li>
<li class="chapter" data-level="3.2.4" data-path="block-ciphers.html"><a href="block-ciphers.html#counter-ctr-mode"><i class="fa fa-check"></i><b>3.2.4</b> Counter (CTR) mode</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="block-ciphers.html"><a href="block-ciphers.html#des-and-aes"><i class="fa fa-check"></i><b>3.3</b> DES and AES</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="block-ciphers.html"><a href="block-ciphers.html#data-encryption-standard-des"><i class="fa fa-check"></i><b>3.3.1</b> Data Encryption Standard (DES)</a></li>
<li class="chapter" data-level="3.3.2" data-path="block-ciphers.html"><a href="block-ciphers.html#advanced-encryption-standard-aes"><i class="fa fa-check"></i><b>3.3.2</b> Advanced Encryption Standard (AES)</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="hash-functions.html"><a href="hash-functions.html"><i class="fa fa-check"></i><b>4</b> Hash functions</a>
<ul>
<li class="chapter" data-level="4.1" data-path="hash-functions.html"><a href="hash-functions.html#some-issues-in-cryptocurrencies"><i class="fa fa-check"></i><b>4.1</b> Some issues in cryptocurrencies</a></li>
<li class="chapter" data-level="4.2" data-path="hash-functions.html"><a href="hash-functions.html#sec:hash_def"><i class="fa fa-check"></i><b>4.2</b> Hash functions</a></li>
<li class="chapter" data-level="4.3" data-path="hash-functions.html"><a href="hash-functions.html#birthday-attacks"><i class="fa fa-check"></i><b>4.3</b> Birthday attacks</a></li>
<li class="chapter" data-level="4.4" data-path="hash-functions.html"><a href="hash-functions.html#the-merkle-damgård-transformation"><i class="fa fa-check"></i><b>4.4</b> The Merkle-Damgård transformation</a></li>
</ul></li>
<li class="part"><span><b>III Asymmetric cryptography</b></span></li>
<li class="chapter" data-level="5" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html"><i class="fa fa-check"></i><b>5</b> Elementary number theory</a>
<ul>
<li class="chapter" data-level="5.1" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#integer-arithmetic"><i class="fa fa-check"></i><b>5.1</b> Integer arithmetic</a></li>
<li class="chapter" data-level="5.2" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#the-euclidean-algorithm"><i class="fa fa-check"></i><b>5.2</b> The euclidean algorithm</a></li>
<li class="chapter" data-level="5.3" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#modular-arithmetic"><i class="fa fa-check"></i><b>5.3</b> Modular arithmetic</a></li>
<li class="chapter" data-level="5.4" data-path="elementary-number-theory.html"><a href="elementary-number-theory.html#efficient-modular"><i class="fa fa-check"></i><b>5.4</b> Modular arithmetic, but efficient</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="algebraic-structures.html"><a href="algebraic-structures.html"><i class="fa fa-check"></i><b>6</b> Algebraic structures</a>
<ul>
<li class="chapter" data-level="6.1" data-path="algebraic-structures.html"><a href="algebraic-structures.html#groups"><i class="fa fa-check"></i><b>6.1</b> Groups</a></li>
<li class="chapter" data-level="6.2" data-path="algebraic-structures.html"><a href="algebraic-structures.html#finite-fields"><i class="fa fa-check"></i><b>6.2</b> Finite fields</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="public-key-encryption.html"><a href="public-key-encryption.html"><i class="fa fa-check"></i><b>7</b> Public-key encryption</a>
<ul>
<li class="chapter" data-level="7.1" data-path="public-key-encryption.html"><a href="public-key-encryption.html#public-key-cryptography"><i class="fa fa-check"></i><b>7.1</b> Public-key cryptography</a></li>
<li class="chapter" data-level="7.2" data-path="public-key-encryption.html"><a href="public-key-encryption.html#the-rsa-encryption-scheme"><i class="fa fa-check"></i><b>7.2</b> The RSA encryption scheme</a></li>
<li class="chapter" data-level="7.3" data-path="public-key-encryption.html"><a href="public-key-encryption.html#security-of-rsa"><i class="fa fa-check"></i><b>7.3</b> Security of RSA</a></li>
<li class="chapter" data-level="7.4" data-path="public-key-encryption.html"><a href="public-key-encryption.html#efficiency-optimizations"><i class="fa fa-check"></i><b>7.4</b> Efficiency optimizations</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html"><i class="fa fa-check"></i><b>8</b> Discrete logarithm cryptosystems</a>
<ul>
<li class="chapter" data-level="8.1" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#the-discrete-logarithm-problem"><i class="fa fa-check"></i><b>8.1</b> The discrete logarithm problem</a></li>
<li class="chapter" data-level="8.2" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#the-diffie-hellman-key-exchange"><i class="fa fa-check"></i><b>8.2</b> The Diffie-Hellman key exchange</a></li>
<li class="chapter" data-level="8.3" data-path="discrete-logarithm-cryptosystems.html"><a href="discrete-logarithm-cryptosystems.html#the-elgamal-encryption-scheme"><i class="fa fa-check"></i><b>8.3</b> The ElGamal encryption scheme</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="signatures.html"><a href="signatures.html"><i class="fa fa-check"></i><b>9</b> Digital signatures</a></li>
<li class="part"><span><b>IV Other topics</b></span></li>
<li class="chapter" data-level="10" data-path="cryptanalysis.html"><a href="cryptanalysis.html"><i class="fa fa-check"></i><b>10</b> Cryptanalysis</a></li>
<li class="appendix"><span><b>Appendices</b></span></li>
<li class="chapter" data-level="A" data-path="ring-theory.html"><a href="ring-theory.html"><i class="fa fa-check"></i><b>A</b> Ring theory</a></li>
<li class="chapter" data-level="B" data-path="primality-testing.html"><a href="primality-testing.html"><i class="fa fa-check"></i><b>B</b> Primality testing</a></li>
<li class="chapter" data-level="C" data-path="refreshers.html"><a href="refreshers.html"><i class="fa fa-check"></i><b>C</b> Refreshers</a>
<ul>
<li class="chapter" data-level="C.1" data-path="refreshers.html"><a href="refreshers.html#set-notation"><i class="fa fa-check"></i><b>C.1</b> Set notation</a></li>
<li class="chapter" data-level="C.2" data-path="refreshers.html"><a href="refreshers.html#probability-theory"><i class="fa fa-check"></i><b>C.2</b> Probability theory</a></li>
<li class="chapter" data-level="C.3" data-path="refreshers.html"><a href="refreshers.html#asymptotic-notation"><i class="fa fa-check"></i><b>C.3</b> Asymptotic notation</a></li>
<li class="chapter" data-level="C.4" data-path="refreshers.html"><a href="refreshers.html#polydiv"><i class="fa fa-check"></i><b>C.4</b> Polynomial division</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Cryptography lecture notes</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="public-key-encryption" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Public-key encryption</h1>
<p>Equipped with the mathematical tools developed in the previous two
chapters, we are now in a position to introduce the concept of
public-key cryptography, and present some of the best-known
constructions in this setting. More precisely, we will learn about:</p>
<ul>
<li><p>The paradigm of public-key cryptography.</p></li>
<li><p>The RSA encryption scheme and its security.</p></li>
<li><p>The ElGamal encryption scheme and its security.</p></li>
</ul>
<div id="public-key-cryptography" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> Public-key cryptography</h2>
<p>In Section <a href="introduction-to-security.html#introduction-to-security">1</a>, we introduced a symmetric
encryption scheme, in which two parties use a shared secret key to
communicate privately. We still have not solved the problem of
establishing this common key in a secure way. We will now introduce a
new type of encryption scheme, which stems from the following idea: what
if we don’t need a shared secret key to have secure communications? This
idea was introduced by Diffie and Hellman in the renowned paper <em>New
directions in cryptography</em>,<a href="#fn26" class="footnote-ref" id="fnref26"><sup>26</sup></a> which is considered to be the birth of
modern cryptography.</p>
<p>They introduced the notion of <em>asymmetric</em> or <em>public-key</em> encryption,
which on a high level works as follows. Imagine that Alice wishes to
send a message to Bob. Bob produces two keys <span class="math inline">\(\mathsf{pk}\)</span> and
<span class="math inline">\(\mathsf{sk}\)</span>, crafted in such a way that whatever is encrypted with
<span class="math inline">\(\mathsf{pk}\)</span> can be decrypted only with <span class="math inline">\(\mathsf{sk}\)</span>. That is, for any
message <span class="math inline">\(\mathsf{m}\)</span>,
<span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}\left(\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m})\right)=\mathsf{m}.\]</span>
Then Bob publishes <span class="math inline">\(\mathsf{pk}\)</span>, so that anyone can know it, and keeps
<span class="math inline">\(\mathsf{sk}\)</span> secret. For this reason, <span class="math inline">\(\mathsf{pk}\)</span> is known as Bob’s
<em>public key</em> and <span class="math inline">\(\mathsf{sk}\)</span> is Bob’s <em>secret key</em>.</p>
<div class="definition">
<p><span id="def:unlabeled-div-70" class="definition"><strong>Definition 7.1  </strong></span><em>An</em> asymmetric (or public-key) encryption scheme <em>is
composed of three efficient algorithms:</em>
<span class="math display">\[(\mathsf{KeyGen},\mathsf{Enc},\mathsf{Dec}).\]</span></p>
<ul>
<li><p><em>The <span class="math inline">\(\mathsf{KeyGen}\)</span> algorithm chooses two keys
<span class="math inline">\(\mathsf{pk},\mathsf{sk}\)</span> of length <span class="math inline">\(\lambda\)</span>, according to some
probability distribution, and such that
<span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}\left(\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m})\right)=\mathsf{m}.\]</span></em></p></li>
<li><p><em>The <span class="math inline">\(\mathsf{Enc}\)</span> algorithm uses the public key <span class="math inline">\(\mathsf{pk}\)</span> to
encrypt a message <span class="math inline">\(\mathsf{m}\)</span>, and outputs the encrypted message
<span class="math display">\[\mathsf{c}=\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m}).\]</span></em></p></li>
<li><p><em>The <span class="math inline">\(\mathsf{Dec}\)</span> algorithm uses the secret key <span class="math inline">\(\mathsf{sk}\)</span> to
decrypt an encrypted message <span class="math inline">\(\mathsf{c}\)</span>, recovering <span class="math inline">\(\mathsf{m}\)</span>
as <span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}(\mathsf{c})=\mathsf{m}.\]</span></em></p></li>
</ul>
<p><em>In this context, <span class="math inline">\(\mathsf{m}\)</span> is called the</em> plaintext<em>, and
<span class="math inline">\(\mathsf{c}\)</span> is said to be its corresponding</em> ciphertext<em>. The keys
<span class="math inline">\(\mathsf{pk}\)</span> and <span class="math inline">\(\mathsf{sk}\)</span> are the</em> public key <em>and</em> secret key<em>,
respectively.</em></p>
</div>
<p>Note that, for such a construction to be secure, we need that the secret
key cannot be efficiently computed from the public key. Otherwise, since
the public key is known to everybody, in particular attackers, this
could be exploited to recover the secret key and decrypt any message.</p>
<p>Another difference with symmetric encryption is that the structure of
the keys is different. In symmetric encryption, we had a key associated
to two parties, Alice and Bob, which was used to send messages both
ways. But, in the explanation above, we just described how Alice sends
messages to Bob, but not the other way around. Note that if Bob tried to
use <span class="math inline">\(\mathsf{sk}\)</span> to encrypt, with the hope that Alice decrypts with
<span class="math inline">\(\mathsf{pk}\)</span>, then anybody would be able to decrypt, since
<span class="math inline">\(\mathsf{pk}\)</span> is public. Therefore, Alice needs another pair of keys,
one public that is used for everybody else to encrypt messages to Alice,
and one secret, that is used by Alice to decrypt messages addressed to
her.</p>
<p>This might seem like a downgrade, since before we needed only one key
and now we have four in total. We emphasize, however, that none of the
secret keys need to be shared, and the public ones can be shared through
an insecure channel. Moreover, we actually have less keys in the
asymmetric case when many parties are involved, as is highlighted by the
following exercise.</p>
<div class="exercise">
<p><span id="exr:unlabeled-div-71" class="exercise"><strong>Exercise 7.1  </strong></span><em>Suppose that we have <span class="math inline">\(n\)</span> parties, and each of them
wishes to communicate with all the others. Compute how many keys are
needed if they use:</em></p>
<ol style="list-style-type: decimal">
<li><p><em>A symmetric encryption scheme.</em></p></li>
<li><p><em>A public-key encryption scheme.</em></p></li>
</ol>
</div>
</div>
<div id="the-rsa-encryption-scheme" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> The RSA encryption scheme</h2>
<p>Although Diffie and Hellman introduced the idea of public-key encryption
in 1976, it was not until 1978 that Rivest, Shamir and Adleman published
the first public-key encryption scheme, which became known as the RSA
encryption scheme.<a href="#fn27" class="footnote-ref" id="fnref27"><sup>27</sup></a> The scheme works as follows.</p>
<ul>
<li><p><span class="math inline">\(\mathsf{KeyGen}\)</span>: on input a security parameter <span class="math inline">\(\lambda\)</span>, choose
two uniformly random prime numbers <span class="math inline">\(p,q\)</span> of bitlength <span class="math inline">\(\lambda/2\)</span>,
and let <span class="math inline">\(N=pq\)</span>. We will work in <span class="math inline">\(\mathbb{Z}_N\)</span>, and call <span class="math inline">\(N\)</span> an <em>RSA
modulus</em>. Choose <span class="math inline">\(e\in\mathbb{Z}_N\)</span>, and compute
<span class="math display">\[d\equiv e^{-1}\pmod{\varphi(N)}.\]</span> Output the public key
<span class="math display">\[\mathsf{pk}=(N,e),\]</span> and the secret key <span class="math display">\[\mathsf{sk}=d.\]</span> Note
that it is crucial that <span class="math inline">\(p,q\)</span> are uniformly random, whereas <span class="math inline">\(e\)</span> can
be a fixed parameter.<a href="#fn28" class="footnote-ref" id="fnref28"><sup>28</sup></a></p></li>
<li><p><span class="math inline">\(\mathsf{Enc}\)</span>: given a message <span class="math inline">\(\mathsf{m}\in\mathbb{Z}_N\)</span>, and the
receiver’s public key <span class="math inline">\((N,e)\)</span>, output a ciphertext
<span class="math display">\[\mathsf{m}^{e}\bmod{N}.\]</span></p></li>
<li><p><span class="math inline">\(\mathsf{Dec}\)</span>: given a ciphertext <span class="math inline">\(\mathsf{c}\)</span> and the secret key
<span class="math inline">\(d\)</span>, output <span class="math display">\[\mathsf{c}^{d}\bmod{N}.\]</span></p></li>
</ul>
<p>There are a few things to consider here. The first is, why does this
even work? That is, how can we be sure that the original message is
recovered after encryption and decryption. We observe that, given a
message <span class="math inline">\(\mathsf{m}\)</span>, we have that
<span class="math display">\[\mathsf{Dec}_{\mathsf{sk}}(\mathsf{Enc}_{\mathsf{pk}}(\mathsf{m}))=\mathsf{Dec}_{\mathsf{sk}}(\mathsf{m}^e\bmod{N})=\left(\mathsf{m}^{e}\right)^d\bmod{N}=\mathsf{m}^{ed}\bmod{N}.\]</span>
Now, we use that <span class="math display">\[d\equiv e^{-1}\pmod{\varphi(N)},\]</span> which means that
there is an integer <span class="math inline">\(k\)</span> such that <span class="math display">\[de=k\varphi(N)+1.\]</span> Thus, by
plugging this into the expression above, we have
<span class="math display">\[\mathsf{m}^{ed}\bmod{N}=\mathsf{m}^{k\varphi(N)+1}\bmod{N}=\left(\left(\mathsf{m}^{\varphi(N)}\right)^k\cdot\mathsf{m}\right)\bmod{N}.\]</span>
Finally, we use Euler’s theorem
(Proposition <a href="algebraic-structures.html#prp:euler">6.3</a>) and
Proposition <a href="algebraic-structures.html#prp:primitive">6.5</a>, which tell us that
<span class="math display">\[\mathsf{m}^{\varphi(N)}\bmod{N}=1,\]</span> and therefore
<span class="math display">\[\mathsf{m}^{ed}\bmod{N}=\mathsf{m}.\]</span> This proves that decryption
indeed reverses encryption.</p>
<p>A second consideration is: are the three algorithms involved efficient?
It is easy to see that <span class="math inline">\(\mathsf{Enc}\)</span> and <span class="math inline">\(\mathsf{Dec}\)</span> are efficient,
since they amount to one modular exponentiation each, which we have seen
that is an efficient computation
(Section <a href="elementary-number-theory.html#efficient-modular">5.4</a>). Let us analyze the
<span class="math inline">\(\mathsf{KeyGen}\)</span> algorithm by breaking it into these steps:</p>
<ol style="list-style-type: decimal">
<li><p>Sample prime numbers of size <span class="math inline">\(\lambda\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(N=pq\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(\varphi(N)\)</span>.</p></li>
<li><p>Compute the inverse of <span class="math inline">\(e\)</span> modulo <span class="math inline">\(\varphi(N)\)</span>.</p></li>
</ol>
<p>Step (1) can be further broken into two parts: sample a random number of
length <span class="math inline">\(\lambda\)</span>, and recognize whether it is a prime or not. We know we
can sample random numbers efficiently and, as discussed in
Section <a href="elementary-number-theory.html#integer-arithmetic">5.1</a> and Appendix <a href="primality-testing.html#primality-testing">B</a>, there are efficient algorithms to
determine the primality of a number.<a href="#fn29" class="footnote-ref" id="fnref29"><sup>29</sup></a></p>
<p>So the strategy is to sample random numbers until we find a prime. But
how many tries do we need? The prime number theorem
(Proposition <a href="elementary-number-theory.html#prp:pnt">5.3</a>) tells us that, for large numbers,
the amount <span class="math inline">\(\pi(n)\)</span> of primes up to <span class="math inline">\(n\)</span> is roughly <span class="math inline">\(n/\log n\)</span> which
means that the probability of a random number being a prime is
approximately <span class="math inline">\(1/\log n\)</span>. This means that, on average, we will need
<span class="math inline">\(\log n=O(\lambda)\)</span> tries before finding a prime. Thus, the total cost
of step (1) is <span class="math inline">\(O(\lambda^3)\)</span>.</p>
<p>Step (2) is simple arithmetic, which is efficient. Computing <span class="math inline">\(\phi(N)\)</span>
in step (3) is easy when knowing the factorization of <span class="math inline">\(N\)</span> since, if
<span class="math inline">\(N=pq\)</span>, then <span class="math display">\[\varphi(N)=(p-1)(q-1),\]</span> as a consequence of
Proposition <a href="elementary-number-theory.html#prp:totient">5.8</a>. Finally, step (4) can be performed efficiently
using the Euclidean algorithm.</p>
<p>The following Sage code is a very simple implementation of the three
algorithms composing the RSA encryption scheme.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="public-key-encryption.html#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set a security parameter</span></span>
<span id="cb11-2"><a href="public-key-encryption.html#cb11-2" aria-hidden="true" tabindex="-1"></a>sec_param <span class="op">=</span> <span class="dv">1024</span></span>
<span id="cb11-3"><a href="public-key-encryption.html#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="public-key-encryption.html#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">### KEY GENERATION </span></span>
<span id="cb11-5"><a href="public-key-encryption.html#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate two prime numbers of length sec_param/2</span></span>
<span id="cb11-6"><a href="public-key-encryption.html#cb11-6" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> random_prime(<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>),<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span>)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb11-7"><a href="public-key-encryption.html#cb11-7" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> random_prime(<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>),<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">/</span><span class="dv">2</span>)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb11-8"><a href="public-key-encryption.html#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the RSA modulus:</span></span>
<span id="cb11-9"><a href="public-key-encryption.html#cb11-9" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> p<span class="op">*</span>q</span>
<span id="cb11-10"><a href="public-key-encryption.html#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute Euler&#39;s phi function on N:</span></span>
<span id="cb11-11"><a href="public-key-encryption.html#cb11-11" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> (p<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>(q<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb11-12"><a href="public-key-encryption.html#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Define Z_N, so that all operations are</span></span>
<span id="cb11-13"><a href="public-key-encryption.html#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="co"># automatically reduced modulo N.</span></span>
<span id="cb11-14"><a href="public-key-encryption.html#cb11-14" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> Integers(N)</span>
<span id="cb11-15"><a href="public-key-encryption.html#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose a public key:</span></span>
<span id="cb11-16"><a href="public-key-encryption.html#cb11-16" aria-hidden="true" tabindex="-1"></a>e <span class="op">=</span> <span class="dv">2</span><span class="op">^</span><span class="dv">16</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-17"><a href="public-key-encryption.html#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the corresponding secret key:</span></span>
<span id="cb11-18"><a href="public-key-encryption.html#cb11-18" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> inverse_mod(e,phi)       <span class="co"># Euclidean algorithm is used under the hood.</span></span>
<span id="cb11-19"><a href="public-key-encryption.html#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="public-key-encryption.html#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="co">### ENCRYPTION - using pk = (N,e)</span></span>
<span id="cb11-21"><a href="public-key-encryption.html#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose a message to encrypt.</span></span>
<span id="cb11-22"><a href="public-key-encryption.html#cb11-22" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">1766704380348666914344743843625136737766400008545151048420480921590988455650205660330488601346206061875826343297391617046317582074537509379708354843527043248265272066232991516996098399031098469466906571566159583240626991926476312991813498057350788070826660741984814907490494865792846706478975249596131279388</span></span>
<span id="cb11-23"><a href="public-key-encryption.html#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Check that the message fits in Z_N.</span></span>
<span id="cb11-24"><a href="public-key-encryption.html#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (m <span class="op">&gt;=</span> N):</span>
<span id="cb11-25"><a href="public-key-encryption.html#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Message too large.&quot;</span>)</span>
<span id="cb11-26"><a href="public-key-encryption.html#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb11-27"><a href="public-key-encryption.html#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Encrypt the message</span></span>
<span id="cb11-28"><a href="public-key-encryption.html#cb11-28" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> Z(m)<span class="op">^</span>e     <span class="co"># Z(m) is written instead of m so that Sage recognizes m </span></span>
<span id="cb11-29"><a href="public-key-encryption.html#cb11-29" aria-hidden="true" tabindex="-1"></a>                   <span class="co"># as an element of Z_N, and performs operations modulo N.</span></span>
<span id="cb11-30"><a href="public-key-encryption.html#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;c = &quot;</span><span class="op">+</span><span class="bu">str</span>(c))</span>
<span id="cb11-31"><a href="public-key-encryption.html#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="public-key-encryption.html#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="public-key-encryption.html#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="co">### DECRYPTION - using sk = d</span></span>
<span id="cb11-34"><a href="public-key-encryption.html#cb11-34" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> Z(c)<span class="op">^</span>d</span>
<span id="cb11-35"><a href="public-key-encryption.html#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;m = &quot;</span><span class="op">+</span><span class="bu">str</span>(m))</span></code></pre></div>
<div class="exercise">
<p><span id="exr:unlabeled-div-72" class="exercise"><strong>Exercise 7.2  </strong></span><em>In the code above, can we replace the line about
computing <span class="math inline">\(\varphi(N)\)</span> by <code>phi = euler_phi(N)</code>?</em></p>
</div>
</div>
<div id="security-of-rsa" class="section level2" number="7.3">
<h2><span class="header-section-number">7.3</span> Security of RSA</h2>
<p>So we know that the scheme works and is efficient. It remains to discuss
security. As mentioned above, the secret key should be hard to deduce
from the public key, otherwise anyone would have access to it, and thus
anyone would be able to decrypt.</p>
<p>By looking again at the generation of the secret key in
<span class="math inline">\(\mathsf{KeyGen}\)</span>, we observe that it can be computed from <span class="math inline">\(e\)</span> and
<span class="math inline">\(\varphi(N)\)</span>. The parameters <span class="math inline">\(e\)</span> and <span class="math inline">\(N\)</span> are public, so what prevents
attackers from computing the secret key? The crucial point is that, in
<span class="math inline">\(\mathsf{KeyGen}\)</span>, we were able to compute <span class="math inline">\(\varphi(N)\)</span> from the
<em>factorization</em> <span class="math inline">\((p,q)\)</span> of <span class="math inline">\(N\)</span>, by computing <span class="math display">\[\varphi(N)=(p-1)(q-1).\]</span>
However, if we do not know the factors of <span class="math inline">\(N\)</span>, we cannot carry out this
computation. Moreover, this works both ways: it can be shown that
knowledge of <span class="math inline">\(\varphi(N)\)</span> allows to factor <span class="math inline">\(N\)</span> efficiently. Thus, the security of RSA relies on the hardness of factorization.</p>
<div class="definition">
<p><span id="def:unlabeled-div-73" class="definition"><strong>Definition 7.2  </strong></span><em>Let <span class="math inline">\(p,q\)</span> be large prime numbers, and let <span class="math inline">\(N=pq\)</span>. The</em> factorization problem <em>consists of recovering <span class="math inline">\(p,q\)</span>, given</em> <span class="math inline">\(N\)</span>.</p>
</div>
<p>As mentioned in
Section <a href="elementary-number-theory.html#integer-arithmetic">5.1</a>, there is no known algorithm for
factoring a product of two large primes efficiently.</p>
<p>Hardness of factorization is a necessary condition for security but,
unfortunately, not a sufficient one. That is, an adversary could still
in principle decrypt a ciphertext without the need of the secret key,
with some other technique. This motivates the introduction of the
following problem.</p>
<div class="definition">
<p><span id="def:unlabeled-div-74" class="definition"><strong>Definition 7.3  </strong></span><em>Let <span class="math inline">\(p,q\)</span> be large primes, and let <span class="math inline">\(N=pq\)</span>. Let
<span class="math inline">\(e\in\mathbb{Z}_N\)</span>. The</em> RSA problem <em>consists of recovering
<span class="math inline">\(\mathsf{m}\in\mathbb{Z}_N\)</span>, given <span class="math inline">\(N,e\)</span> and <span class="math inline">\(\mathsf{m}^e\bmod{N}\)</span>.</em></p>
</div>
<p>Clearly if factorization is easy then the RSA problem is also easy, but
the implication in the other direction is not known to be true or false
so far. However, as is the case with the factorization problem, there
have been extensive attacks against the RSA problem, and no better
attack than factorization of <span class="math inline">\(N\)</span> has been found. This provides a
reasonable guarantee that the problem is indeed hard, even if we lack a
formal proof.</p>
<p>For security against current computational power, most organizations
suggest a security parameter of at least <span class="math inline">\(\lambda=2048\)</span> (see
<a href="https://www.keylength.com/" class="uri">https://www.keylength.com/</a>). That is, an RSA modulus <span class="math inline">\(N\)</span> of bitlength
<span class="math inline">\(2048\)</span> is believed to be secure against current factorization attempts.
To date, the highest RSA modulus to be factored has bitlength <span class="math inline">\(829\)</span>, and
took about <span class="math inline">\(2700\)</span> core-years.<a href="#fn30" class="footnote-ref" id="fnref30"><sup>30</sup></a></p>
<div class="figure">
<img src="security.png" alt="" />
<p class="caption">Webcomic by xkcd (<a href="https://xkcd.com/538/" class="uri">https://xkcd.com/538/</a>).</p>
</div>
<p>So is this enough to call the RSA scheme secure? Unfortunately, no,
since it is vulnerable to other attacks that do not depend on recovering
the secret key. We consider the following scenario: suppose that Alice
is sending Bob a date of the year, in the format <span class="math inline">\(DDMM\)</span>, where <span class="math inline">\(DD\)</span> is
the day and <span class="math inline">\(MM\)</span> is the month. An attacker knows this, and also has
access to Bob’s public key <span class="math inline">\((N,e)\)</span>, since anyone can obtain public keys.
The attacker eavesdrops the ciphertext <span class="math inline">\(\mathsf{c}\)</span> that Alice sends
Bob, and then computes <span class="math display">\[(DDMM)^{e}\bmod{N}\]</span> for each
<span class="math inline">\(DD\in\{1,\dots,31\}\)</span> and <span class="math inline">\(MM\in\{1,\dots,12\}\)</span>. The attacker compares
the list of results with <span class="math inline">\(\mathsf{c}\)</span> until they find a match, which
tells them the date that was encrypted in <span class="math inline">\(\mathsf{c}\)</span>. This is known as
a <em>chosen-plaintext attack (CPA)</em>, since the adversary can obtain the
encryptions of messages of their own choice. More precisely, we
introduce the following definition.</p>
<p>Below is some code for running this attack. As an attacker, we have
access to the security parameter <span class="math inline">\(\lambda\)</span>, the RSA modulus <code>N</code>, and the
encryption exponent <code>e</code>. We intercept some ciphertext <code>c</code>, and
run the attack by comparing <code>c</code> with the encryption of each
possible message.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="public-key-encryption.html#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">### Auxiliary function</span></span>
<span id="cb12-2"><a href="public-key-encryption.html#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Write day/month in the format DDMM</span></span>
<span id="cb12-3"><a href="public-key-encryption.html#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="bu">format</span>(day,month):</span>
<span id="cb12-4"><a href="public-key-encryption.html#cb12-4" aria-hidden="true" tabindex="-1"></a>    day <span class="op">=</span> <span class="bu">str</span>(day)</span>
<span id="cb12-5"><a href="public-key-encryption.html#cb12-5" aria-hidden="true" tabindex="-1"></a>    month <span class="op">=</span> <span class="bu">str</span>(month)</span>
<span id="cb12-6"><a href="public-key-encryption.html#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(day)<span class="op">&lt;</span><span class="dv">2</span>:</span>
<span id="cb12-7"><a href="public-key-encryption.html#cb12-7" aria-hidden="true" tabindex="-1"></a>        day <span class="op">=</span> <span class="st">&quot;0&quot;</span> <span class="op">+</span> day</span>
<span id="cb12-8"><a href="public-key-encryption.html#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(month)<span class="op">&lt;</span><span class="dv">2</span>:</span>
<span id="cb12-9"><a href="public-key-encryption.html#cb12-9" aria-hidden="true" tabindex="-1"></a>        month <span class="op">=</span> <span class="st">&quot;0&quot;</span> <span class="op">+</span> month</span>
<span id="cb12-10"><a href="public-key-encryption.html#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>(day <span class="op">+</span> month)</span>
<span id="cb12-11"><a href="public-key-encryption.html#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="public-key-encryption.html#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="public-key-encryption.html#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co">### CPA attack</span></span>
<span id="cb12-14"><a href="public-key-encryption.html#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Known data</span></span>
<span id="cb12-15"><a href="public-key-encryption.html#cb12-15" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">5084923486342919837749158826454356403346569259981671106186333244915073155770076069992841087736392422153624652509603466938787643616193693073473157600021972806569653700645220307421997336878744077854611907151783228311349496598408945325528067737317894046858136344781889361465025184092329532181879347609645469411</span></span>
<span id="cb12-16"><a href="public-key-encryption.html#cb12-16" aria-hidden="true" tabindex="-1"></a>Z <span class="op">=</span> Integers(N)</span>
<span id="cb12-17"><a href="public-key-encryption.html#cb12-17" aria-hidden="true" tabindex="-1"></a>e <span class="op">=</span> <span class="dv">2</span><span class="op">^</span><span class="dv">16</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb12-18"><a href="public-key-encryption.html#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Intercepted ciphertext</span></span>
<span id="cb12-19"><a href="public-key-encryption.html#cb12-19" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">105605073257617821289274662706975761114405451836859336022070629464826511380165185130471900685486223806100216503822026792593184983241872596132965357095523791203088732252839389155546759634409370409954409570109113362453081088475465706906936653890215874964553000419826116298403548222781967172784767448559073540</span></span>
<span id="cb12-20"><a href="public-key-encryption.html#cb12-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-21"><a href="public-key-encryption.html#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Running the attack</span></span>
<span id="cb12-22"><a href="public-key-encryption.html#cb12-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> month <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">13</span>):</span>
<span id="cb12-23"><a href="public-key-encryption.html#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> day <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,<span class="dv">32</span>):</span>
<span id="cb12-24"><a href="public-key-encryption.html#cb12-24" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> <span class="bu">format</span>(day,month)</span>
<span id="cb12-25"><a href="public-key-encryption.html#cb12-25" aria-hidden="true" tabindex="-1"></a>        c_candidate <span class="op">=</span> Z(m)<span class="op">^</span>e</span>
<span id="cb12-26"><a href="public-key-encryption.html#cb12-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c_candidate <span class="op">==</span> c:</span>
<span id="cb12-27"><a href="public-key-encryption.html#cb12-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;Recovered plaintext: &quot;</span><span class="op">+</span><span class="bu">str</span>(m))</span></code></pre></div>
<p>The version of RSA described above is known as <em>textbook RSA</em>, because
it is a version simplified for didactic purposes, but is not secure
against chosen-plaintext attacks, and thus not secure for real-world
use.</p>
<p>How could such an attack happened? We boil it down to three facts:</p>
<ol style="list-style-type: decimal">
<li><p>The receiver’s public key is known by the attacker, so the attacker
can compute ciphertexts of messages of their choice.</p></li>
<li><p>The set of possible messages is small, so it is efficient for the
attacker to compute ciphertexts of every possible message.</p></li>
<li><p>The encryption algorithm was deterministic, so the attacker can
compare their list of ciphertexts with the intercepted ciphertext
and find a match. Recall <a href="introduction-to-security.html#principle:3" reference-type="ref" reference="principle:3">Principle 3</a> from the beginning of the course: there is
no security without randomness.</p></li>
</ol>
<p>Fact (1) happens by design of public-key schemes. There is not much we
can do about fact (2) either, since a good encryption scheme should
allow users to communicate any data. Therefore, to fix RSA we need to do
something about fact (3).</p>
<p>The idea is to modify the message before running it through the RSA
encryption algorithm, and add some randomness to it. There are many
different proposals to achieve this, collectively known as <em>padded RSA</em>.
We describe one successful variant known as <em>RSA-OAEP</em>.<a href="#fn31" class="footnote-ref" id="fnref31"><sup>31</sup></a></p>
<p>Unfortunately, it is not as simple as appending some random bits at the
end of the message, and we need a more involved process. Let
<span class="math display">\[G:\{0,1\}^{k_0}\rightarrow\{0,1\}^{\ell+k_1},\qquad H:\{0,1\}^{\ell+k_1}\rightarrow \{0,1\}^{k_0}\]</span>
be two hash functions, where <span class="math inline">\(k_0,k_1\)</span> are such that <span class="math inline">\(\lambda=O(k_0)\)</span>
and <span class="math inline">\(\lambda=O(k_2)\)</span>, and <span class="math inline">\(\ell+k_0+k_1\)</span> is smaller than the bitlength
of <span class="math inline">\(N\)</span>. We describe how to modify a message <span class="math inline">\(\mathsf{m}\)</span> of bitlength
<span class="math inline">\(\ell\)</span>. We introduce randomness by uniformly sampling a bitstring
<span class="math inline">\(r\in\{0,1\}^{k_0}\)</span>, and then compute:
<span class="math display">\[s=\mathsf{m}|\mathbf 0^{k_1}\oplus G(r),\qquad t= r\oplus H(s),\]</span>
where <span class="math inline">\(\mathsf{m}|\mathbf 0^{k_1}\)</span> is the bitstring <span class="math inline">\(\mathsf{m}\)</span>,
concatenated with the string of zeros of length <span class="math inline">\(k_1\)</span>. Then, we set the
new message as <span class="math inline">\(\hat{\mathsf{m}}=(s,t)\)</span>, which is then run through
textbook RSA. Observe that <span class="math inline">\(s\in\{0,1\}^{\ell+k_1}\)</span> and
<span class="math inline">\(t\in\{0,1\}^{k_0}\)</span>, so the message <span class="math inline">\(\hat{\mathsf{m}}\)</span> has the appropriate
length.</p>
<p>We summarize the construction in the following diagram.</p>
<p><img src="_main_files/figure-html/unnamed-chunk-32-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="exercise">
<p><span id="exr:unlabeled-div-75" class="exercise"><strong>Exercise 7.3  </strong></span><em>Describe the decryption procedure that corresponds to
RSA-OAEP.</em></p>
</div>
<p>With these modifications, we can finally claim that the RSA cryptosystem
is secure.</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-76" class="proposition"><strong>Proposition 7.1  </strong></span><em>If the RSA problem is hard and <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> behave
as ideal<a href="#fn32" class="footnote-ref" id="fnref32"><sup>32</sup></a> hash functions, then the RSA-OAEP encryption scheme is
secure.</em></p>
</div>
<p>Note that the textbook version of RSA is also <em>malleable</em>. This means
that, given a ciphertext of some message, it is easy to produce a
ciphertext of a related message. For example, given a ciphertext
<span class="math inline">\(\mathsf{c}\)</span> for the message <span class="math inline">\(\mathsf{m}\)</span>, i.e.
<span class="math display">\[\mathsf{c}=\mathsf{m}^e\bmod{N},\]</span> an adversary can compute
<span class="math display">\[\mathsf{c}&#39;=2^e\mathsf{c}\bmod{N}=(2\mathsf{m})^e\bmod{N},\]</span> which is
a valid ciphertext for the message <span class="math inline">\(2\mathsf{m}\bmod{N}\)</span>. The OAEP
transformation also makes the scheme non-malleable.</p>
</div>
<div id="efficiency-optimizations" class="section level2" number="7.4">
<h2><span class="header-section-number">7.4</span> Efficiency optimizations</h2>
<p>As discussed above, the algorithms involved in RSA are all efficient,
although not particularly fast. In this section, we look at some
efficiency tricks to speed up the computations.</p>
<p>A simple one is to choose the encryption exponent <span class="math inline">\(e\)</span> so that its binary
representation has many zeros. This has an impact on the computation of
the exponentiation when the square-and-multiply algorithm
(Section <a href="elementary-number-theory.html#efficient-modular">5.4</a>) is used. Recall that,
for each bit, the algorithm consists of one squaring and, if the bit is
<span class="math inline">\(1\)</span>, one multiplication, both operations modulo <span class="math inline">\(n\)</span>. By choosing an
exponent like <span class="math inline">\(e=2^{n}+1\)</span>, with binary representation
<span class="math display">\[[e]_2=1\underbrace{0\dots0}_{n-1}1,\]</span> we ensure that we skip most of
the multiplications. In practice, often the exponent <span class="math inline">\(2^{16}+1\)</span> is
chosen.</p>
<p>Another possible optimization is to make use of the Chinese remainder
theorem (Proposition <a href="elementary-number-theory.html#prp:crt">5.9</a>), and perform the operations in <span class="math inline">\(\mathbb{Z}_p\)</span> and
<span class="math inline">\(\mathbb{Z}_q\)</span>, and then reconstruct the plaintext in <span class="math inline">\(\mathbb{Z}_N\)</span>,
instead of working in <span class="math inline">\(\mathbb{Z}_N\)</span> directly. Since <span class="math inline">\(p,q\)</span> are half the
size of <span class="math inline">\(N\)</span>, exponentiations are cheaper here, and overall the procedure
is roughly four times faster. More precisely, let
<span class="math inline">\(\mathsf{c}\in\mathbb{Z}_N\)</span> be a ciphertext, and let <span class="math inline">\(d\in\mathbb{Z}_N\)</span>
be the secret key. We compute <span class="math display">\[\begin{aligned}
&amp; \mathsf{c}_p = \mathsf{c}\bmod{p} &amp; \mathsf{c}_q = \mathsf{c}\bmod{q},\\
&amp; d_p = d\bmod{\varphi(p)},\qquad &amp; d_q = d\bmod{\varphi(q)},
\end{aligned}\]</span> and use these to decrypt in <span class="math inline">\(\mathbb{Z}_p\)</span> and
<span class="math inline">\(\mathbb{Z}_q\)</span>:
<span class="math display">\[\mathsf{m}_p = \mathsf{c}_p^{d_p} \bmod{p},\qquad \mathsf{m}_q = \mathsf{c}_q^{d_q} \bmod{q}.\]</span>
Now, we have <span class="math inline">\(\mathsf{m}_p\)</span> and <span class="math inline">\(\mathsf{m}_q\)</span>, and the Chinese
remainder theorem tells us that there is a unique
<span class="math inline">\(\mathsf{m}\in\mathbb{Z}_N\)</span> such that <span class="math display">\[\begin{aligned}
&amp; \mathsf{m}\equiv \mathsf{m}_p \pmod{p},
&amp; \mathsf{m}\equiv \mathsf{m}_q \pmod{q},
\end{aligned}\]</span> and the second part of the theorem gives us a formula to
explicitly recover such <span class="math inline">\(\mathsf{m}\)</span>.</p>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="26">
<li id="fn26"><p>Diffie, W., &amp; Hellman, M. (1976). New directions in cryptography.
<em>IEEE transactions on Information Theory</em>, 22(6), 644-654.<a href="public-key-encryption.html#fnref26" class="footnote-back">↩︎</a></p></li>
<li id="fn27"><p>Rivest, R. L., Shamir, A., &amp; Adleman, L. (1978). A method for
obtaining digital signatures and public-key cryptosystems.
<em>Communications of the ACM</em>, 21(2), 120-126.<a href="public-key-encryption.html#fnref27" class="footnote-back">↩︎</a></p></li>
<li id="fn28"><p>Initially, it was suggested to use <span class="math inline">\(e=3\)</span> for efficiency, although
this opened the gates to some attacks. Nowadays, the most common
option is <span class="math inline">\(e=2^{16}+1\)</span>.<a href="public-key-encryption.html#fnref28" class="footnote-back">↩︎</a></p></li>
<li id="fn29"><p>In practice, most of the time we use the Miller–Rabin algorithm,
which runs in time <span class="math inline">\(O(\lambda^2)\)</span>, although it can produce false
positives with a very small probability. A completely fail-safe
alternative is the AKS algorithm, which is still efficient but much
slower. More detail can be found in Appendix <a href="primality-testing.html#primality-testing">B</a>.<a href="public-key-encryption.html#fnref29" class="footnote-back">↩︎</a></p></li>
<li id="fn30"><p><a href="https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2020-February/001166.html" class="uri">https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2020-February/001166.html</a><a href="public-key-encryption.html#fnref30" class="footnote-back">↩︎</a></p></li>
<li id="fn31"><p>OAEP stands for <em>optimal asymmetric encryption padding</em>.<a href="public-key-encryption.html#fnref31" class="footnote-back">↩︎</a></p></li>
<li id="fn32"><p>Essentially, this means that the hash functions output uniformly
random elements of their respective codomains. This is not true for
actual hash functions, but it does not make a difference in
practice.<a href="public-key-encryption.html#fnref32" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="algebraic-structures.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="discrete-logarithm-cryptosystems.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
