<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 Randomness in cryptography | Cryptography lecture notes</title>
  <meta name="description" content="2 Randomness in cryptography | Cryptography lecture notes" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="2 Randomness in cryptography | Cryptography lecture notes" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 Randomness in cryptography | Cryptography lecture notes" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="introduction-to-security.html"/>
<link rel="next" href="block-ciphers.html"/>
<script src="libs/header-attrs-2.6/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="part"><span><b>I Introduction to modern cryptography</b></span></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Front page</a></li>
<li class="chapter" data-level="1" data-path="introduction-to-security.html"><a href="introduction-to-security.html"><i class="fa fa-check"></i><b>1</b> Introduction to security</a>
<ul>
<li class="chapter" data-level="1.1" data-path="introduction-to-security.html"><a href="introduction-to-security.html#what-cryptography-is-and-is-not"><i class="fa fa-check"></i><b>1.1</b> What cryptography is and is not</a></li>
<li class="chapter" data-level="1.2" data-path="introduction-to-security.html"><a href="introduction-to-security.html#fundamental-security-principles"><i class="fa fa-check"></i><b>1.2</b> Fundamental security principles</a></li>
<li class="chapter" data-level="1.3" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-parameter"><i class="fa fa-check"></i><b>1.3</b> Security parameter</a></li>
<li class="chapter" data-level="1.4" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-level"><i class="fa fa-check"></i><b>1.4</b> Security level</a></li>
</ul></li>
<li class="part"><span><b>II Symmetric cryptography</b></span></li>
<li class="chapter" data-level="2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html"><i class="fa fa-check"></i><b>2</b> Randomness in cryptography</a>
<ul>
<li class="chapter" data-level="2.1" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#one-time-pad"><i class="fa fa-check"></i><b>2.1</b> One-time pad</a></li>
<li class="chapter" data-level="2.2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:prngs"><i class="fa fa-check"></i><b>2.2</b> Pseudorandom generators</a></li>
<li class="chapter" data-level="2.3" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:examples"><i class="fa fa-check"></i><b>2.3</b> Linear feedback shift registers</a></li>
<li class="chapter" data-level="2.4" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#true-randomness"><i class="fa fa-check"></i><b>2.4</b> True randomness</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="block-ciphers.html"><a href="block-ciphers.html"><i class="fa fa-check"></i><b>3</b> Block ciphers</a>
<ul>
<li class="chapter" data-level="3.1" data-path="block-ciphers.html"><a href="block-ciphers.html#overview-of-block-ciphers"><i class="fa fa-check"></i><b>3.1</b> Overview of block ciphers</a></li>
<li class="chapter" data-level="3.2" data-path="block-ciphers.html"><a href="block-ciphers.html#modes-of-operation"><i class="fa fa-check"></i><b>3.2</b> Modes of operation</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="block-ciphers.html"><a href="block-ciphers.html#electronic-codebook-ecb-mode"><i class="fa fa-check"></i><b>3.2.1</b> Electronic codebook (ECB) mode</a></li>
<li class="chapter" data-level="3.2.2" data-path="block-ciphers.html"><a href="block-ciphers.html#cipher-block-chaining-cbc-mode"><i class="fa fa-check"></i><b>3.2.2</b> Cipher block chaining (CBC) mode</a></li>
<li class="chapter" data-level="3.2.3" data-path="block-ciphers.html"><a href="block-ciphers.html#output-feedback-ofb-mode"><i class="fa fa-check"></i><b>3.2.3</b> Output feedback (OFB) mode</a></li>
<li class="chapter" data-level="3.2.4" data-path="block-ciphers.html"><a href="block-ciphers.html#counter-ctr-mode"><i class="fa fa-check"></i><b>3.2.4</b> Counter (CTR) mode</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="block-ciphers.html"><a href="block-ciphers.html#des-and-aes"><i class="fa fa-check"></i><b>3.3</b> DES and AES</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="block-ciphers.html"><a href="block-ciphers.html#data-encryption-standard-des"><i class="fa fa-check"></i><b>3.3.1</b> Data Encryption Standard (DES)</a></li>
<li class="chapter" data-level="3.3.2" data-path="block-ciphers.html"><a href="block-ciphers.html#advanced-encryption-standard-aes"><i class="fa fa-check"></i><b>3.3.2</b> Advanced Encryption Standard (AES)</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="hash-functions.html"><a href="hash-functions.html"><i class="fa fa-check"></i><b>4</b> Hash functions</a>
<ul>
<li class="chapter" data-level="4.1" data-path="hash-functions.html"><a href="hash-functions.html#some-issues-in-cryptocurrencies"><i class="fa fa-check"></i><b>4.1</b> Some issues in cryptocurrencies</a></li>
<li class="chapter" data-level="4.2" data-path="hash-functions.html"><a href="hash-functions.html#sec:hash_def"><i class="fa fa-check"></i><b>4.2</b> Hash functions</a></li>
<li class="chapter" data-level="4.3" data-path="hash-functions.html"><a href="hash-functions.html#birthday-attacks"><i class="fa fa-check"></i><b>4.3</b> Birthday attacks</a></li>
<li class="chapter" data-level="4.4" data-path="hash-functions.html"><a href="hash-functions.html#the-merkle-damgÃ¥rd-transformation"><i class="fa fa-check"></i><b>4.4</b> The Merkle-DamgÃ¥rd transformation</a></li>
</ul></li>
<li class="part"><span><b>III Asymmetric cryptography</b></span></li>
<li class="chapter" data-level="5" data-path="number-theory.html"><a href="number-theory.html"><i class="fa fa-check"></i><b>5</b> Elementary number theory</a>
<ul>
<li class="chapter" data-level="5.1" data-path="number-theory.html"><a href="number-theory.html#modular-arithmetic"><i class="fa fa-check"></i><b>5.1</b> Modular arithmetic</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="algebraic-structures.html"><a href="algebraic-structures.html"><i class="fa fa-check"></i><b>6</b> Algebraic structures</a></li>
<li class="chapter" data-level="7" data-path="pke.html"><a href="pke.html"><i class="fa fa-check"></i><b>7</b> Public-key encryption</a></li>
<li class="chapter" data-level="8" data-path="dh.html"><a href="dh.html"><i class="fa fa-check"></i><b>8</b> The DiffieâHellman key exchange</a></li>
<li class="chapter" data-level="9" data-path="signatures.html"><a href="signatures.html"><i class="fa fa-check"></i><b>9</b> Digital signatures</a></li>
<li class="part"><span><b>IV Other topics</b></span></li>
<li class="chapter" data-level="10" data-path="cryptanalysis.html"><a href="cryptanalysis.html"><i class="fa fa-check"></i><b>10</b> Cryptanalysis</a></li>
<li class="appendix"><span><b>Appendices</b></span></li>
<li class="chapter" data-level="A" data-path="refreshers.html"><a href="refreshers.html"><i class="fa fa-check"></i><b>A</b> Refreshers</a>
<ul>
<li class="chapter" data-level="A.1" data-path="refreshers.html"><a href="refreshers.html#set-notation"><i class="fa fa-check"></i><b>A.1</b> Set notation</a></li>
<li class="chapter" data-level="A.2" data-path="refreshers.html"><a href="refreshers.html#probability-theory"><i class="fa fa-check"></i><b>A.2</b> Probability theory</a></li>
<li class="chapter" data-level="A.3" data-path="refreshers.html"><a href="refreshers.html#asymptotic-notation"><i class="fa fa-check"></i><b>A.3</b> Asymptotic notation</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Cryptography lecture notes</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="randomness-in-cryptography" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Randomness in cryptography</h1>
<p>As we saw above, and made explicit in
<a href="introduction-to-security.html#principle:3" reference-type="ref" reference="principle:3">PrincipleÂ 3</a>, we require randomness to guarantee secure
cryptography. In this section, we will give some thought to how to
obtain this randomness in the first place, and what to do when we do not
have enough of it. As a motivating example, we will start by describing
a well-known encryption scheme.</p>
<p>We will learn about:</p>
<ol style="list-style-type: decimal">
<li><p>The one-time pad encryption scheme;</p></li>
<li><p>Pseudorandom generators;</p></li>
<li><p>Sources of randomness.</p></li>
</ol>
<div id="one-time-pad" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> One-time pad</h2>
<p>The <em>one-time pad (OTP)</em> is an old encryption scheme, which was already
known in the late 19th century, and was widely used in the 20th century
for many military and intelligence operations.</p>
<p>The idea is extremely simple. Let us first recall the <em>exclusive or</em>
(<span class="math inline">\(\mathsf{XOR}\)</span>) logic operation. Given two bits <span class="math inline">\(b_0,b_1\in\{0,1\}\)</span>,
the operation is defined as
<span class="math display">\[\mathsf{XOR}(b_0,b_1)=b_0\oplus b_1=\left\{\begin{array}{ll}
    0 &amp; \text{if }b_0=b_1, \\
    1 &amp; \text{if }b_0\neq b_1. \\
\end{array}\right.\]</span> Equivalently, the operation corresponds to the
following truth table:</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th align="center"><span class="math inline">\(b_0\)</span></th>
<th align="center"><span class="math inline">\(b_1\)</span></th>
<th align="center"><span class="math inline">\(b_0\oplus b_1\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr class="odd">
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody>
</table>
</div>
<p>We extend the notation to bitstrings of any length, i.e., given two
bistrings <span class="math inline">\(\mathbf b_0\)</span> and <span class="math inline">\(\mathbf b_1\)</span> of the same length, we define
<span class="math display">\[\mathbf b_0 \oplus \mathbf b_1\]</span> to be the bistring that results from
<span class="math inline">\(\mathsf{XOR}\)</span>âing each bit of <span class="math inline">\(\mathbf b_0\)</span> with the bit in the same
position of <span class="math inline">\(\mathbf b_1\)</span>.</p>
<p>Assume that Alice wants to send an encrypted message to Bob. The
one-time pad works as follows. Key generation consists of choosing as a
secret key a uniformly random bitstring of length <span class="math inline">\(\lambda\)</span> as the key:
<span class="math display">\[\mathsf{k}=k_1k_2\dots k_\lambda.\]</span> We denote this process by
<span class="math inline">\(\mathsf{k}\gets\{0,1\}^\lambda\)</span>. Let <span class="math inline">\(m\)</span> be a message that Alice wants
to encrypt, written as a bitstring<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>
<span class="math display">\[\mathsf{m}=m_1m_2\dots m_\lambda\]</span> of the same length. Then, the
one-time pad encryption scheme works by <span class="math inline">\(\mathsf{XOR}\)</span>âing each message
bit with the corresponding key bit. More precisely, for the <span class="math inline">\(i\)</span>th bit of
the message, we compute <span class="math display">\[\mathsf{c}= \mathsf{m}\oplus \mathbf k,\]</span>
which is sent to Bob. Note that, because the <span class="math inline">\(\mathsf{XOR}\)</span> operation is
its own inverse, the decryption algorithm works exactly like encryption.
That is, Bob can recover the message by computing
<span class="math display">\[\mathsf{m}= \mathsf{c}\oplus\mathsf{k}.\]</span></p>
<p>The first property that we want from any encryption scheme is
<em>correctness</em>, which means that for any message <span class="math inline">\(\mathsf{m}\)</span> and any key
<span class="math inline">\(\mathsf{k}\)</span>, we have that
<span class="math display">\[\mathsf{Dec}_{\mathsf{k}}(\mathsf{Enc}_{\mathsf{k}}(\mathsf{m}))=\mathsf{m},\]</span>
that is, if we encrypt and decrypt, we should recover the same message.
Otherwise Alice and Bob will not be able to communicate.</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-7" class="proposition"><strong>Proposition 2.1  </strong></span><em>The one-time pad is a correct encryption scheme.</em></p>
</div>
<div class="proof">
<p><span id="unlabeled-div-8" class="proof"><em>Proof</em>. </span>Using the definitions of encryption and decryption, we have
that
<span class="math display">\[\mathsf{Dec}_{\mathsf{k}}(\mathsf{Enc}_{\mathsf{k}}(\mathsf{m}))=\mathsf{Dec}_{\mathsf{k}}(\mathsf{m}\oplus\mathsf{k})=(\mathsf{m}\oplus\mathsf{k})\oplus \mathsf{k}= \mathsf{m}\oplus (\mathsf{k}\oplus\mathsf{k})=\mathsf{m}\oplus\mathbf 0=\mathsf{m},\]</span>
where <span class="math inline">\(\mathbf 0\)</span> means the string of zeroes of size <span class="math inline">\(\lambda\)</span>. In the
last two steps, we used, respectively, that <span class="math inline">\(\mathsf{XOR}\)</span>âing any
string with itself produces <span class="math inline">\(\mathbf 0\)</span>, and that <span class="math inline">\(\mathsf{XOR}\)</span>âing any
string with <span class="math inline">\(\mathbf 0\)</span> does not change the string.</p>
</div>
<p>Here is a straightforward implementation of the one-time pad. In this
example, we want to send a message with <span class="math inline">\(12\)</span> ASCII characters, so each
character will require <span class="math inline">\(8\)</span> bits. Thus, we choose a key length of <span class="math inline">\(96\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="randomness-in-cryptography.html#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sage.crypto.util <span class="im">import</span> ascii_integer</span>
<span id="cb2-2"><a href="randomness-in-cryptography.html#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sage.crypto.util <span class="im">import</span> bin_to_ascii</span>
<span id="cb2-3"><a href="randomness-in-cryptography.html#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="randomness-in-cryptography.html#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set a security parameter</span></span>
<span id="cb2-5"><a href="randomness-in-cryptography.html#cb2-5" aria-hidden="true" tabindex="-1"></a>sec_param <span class="op">=</span> <span class="dv">96</span></span>
<span id="cb2-6"><a href="randomness-in-cryptography.html#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="randomness-in-cryptography.html#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the XOR operation:</span></span>
<span id="cb2-8"><a href="randomness-in-cryptography.html#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> xor(a,b):</span>
<span id="cb2-9"><a href="randomness-in-cryptography.html#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mod(<span class="bu">int</span>(a)<span class="op">+</span><span class="bu">int</span>(b),<span class="dv">2</span>) <span class="co"># You will learn why this is equivalent</span></span>
<span id="cb2-10"><a href="randomness-in-cryptography.html#cb2-10" aria-hidden="true" tabindex="-1"></a>                                <span class="co"># to XOR later in the course</span></span>
<span id="cb2-11"><a href="randomness-in-cryptography.html#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="randomness-in-cryptography.html#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">### KEY GENERATION </span></span>
<span id="cb2-13"><a href="randomness-in-cryptography.html#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a random key of length sec_param</span></span>
<span id="cb2-14"><a href="randomness-in-cryptography.html#cb2-14" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> random_vector(GF(<span class="dv">2</span>),sec_param)</span>
<span id="cb2-15"><a href="randomness-in-cryptography.html#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="randomness-in-cryptography.html#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co">### ENCRYPTION </span></span>
<span id="cb2-17"><a href="randomness-in-cryptography.html#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose a message</span></span>
<span id="cb2-18"><a href="randomness-in-cryptography.html#cb2-18" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="st">&quot;Hello there.&quot;</span></span>
<span id="cb2-19"><a href="randomness-in-cryptography.html#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Process the message into a bitstring</span></span>
<span id="cb2-20"><a href="randomness-in-cryptography.html#cb2-20" aria-hidden="true" tabindex="-1"></a>m_bin <span class="op">=</span> <span class="bu">str</span>(BinaryStrings().encoding(m))</span>
<span id="cb2-21"><a href="randomness-in-cryptography.html#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="randomness-in-cryptography.html#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Encrypt the message bit by bit</span></span>
<span id="cb2-23"><a href="randomness-in-cryptography.html#cb2-23" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb2-24"><a href="randomness-in-cryptography.html#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="bu">len</span>(m_bin)<span class="op">&lt;=</span>sec_param):</span>
<span id="cb2-25"><a href="randomness-in-cryptography.html#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(m_bin)):</span>
<span id="cb2-26"><a href="randomness-in-cryptography.html#cb2-26" aria-hidden="true" tabindex="-1"></a>        c <span class="op">+=</span> <span class="bu">str</span>(xor(m_bin[i],k[i]))</span>
<span id="cb2-27"><a href="randomness-in-cryptography.html#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Ciphertext: &quot;</span><span class="op">+</span>c)</span>
<span id="cb2-28"><a href="randomness-in-cryptography.html#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb2-29"><a href="randomness-in-cryptography.html#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Message too long. Need a longer key.&quot;</span>)</span>
<span id="cb2-30"><a href="randomness-in-cryptography.html#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="randomness-in-cryptography.html#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co">### DECRYPTION </span></span>
<span id="cb2-32"><a href="randomness-in-cryptography.html#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co"># We use the same ciphertext obtained in the encryption part. </span></span>
<span id="cb2-33"><a href="randomness-in-cryptography.html#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="randomness-in-cryptography.html#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Decrypt the ciphertext bit by bit</span></span>
<span id="cb2-35"><a href="randomness-in-cryptography.html#cb2-35" aria-hidden="true" tabindex="-1"></a>m_bin <span class="op">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb2-36"><a href="randomness-in-cryptography.html#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="bu">len</span>(c)<span class="op">&lt;=</span>sec_param):</span>
<span id="cb2-37"><a href="randomness-in-cryptography.html#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(c)):</span>
<span id="cb2-38"><a href="randomness-in-cryptography.html#cb2-38" aria-hidden="true" tabindex="-1"></a>        m_bin <span class="op">+=</span> <span class="bu">str</span>(xor(c[i],k[i]))</span>
<span id="cb2-39"><a href="randomness-in-cryptography.html#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Plaintext: &quot;</span><span class="op">+</span>bin_to_ascii(m_bin))</span>
<span id="cb2-40"><a href="randomness-in-cryptography.html#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb2-41"><a href="randomness-in-cryptography.html#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Ciphertext too long. Need a longer key.&quot;</span>)</span></code></pre></div>
<p>The one-time pad receives its name from the fact that, when the key is
used only once, the scheme has <em>perfect secrecy</em>. This means that the
ciphertext produced reveals absolutely no information about the
underlying plaintext, besides its length. We formalize this by saying
that, given a ciphertext and two messages, the ciphertext has the same
probability of corresponding to each of the messages.</p>
<div class="definition">
<p><span id="def:unlabeled-div-9" class="definition"><strong>Definition 2.1  </strong></span><em>An encryption scheme has</em> perfect secrecy <em>when, for
a uniformly random key <span class="math inline">\(\mathsf{k}\)</span>, all ciphertexts <span class="math inline">\(\mathsf{c}\)</span> and all pairs of
messages <span class="math inline">\(\mathsf{m}_0,\mathsf{m}_1\)</span>,</em>
<span class="math display">\[\Pr[\mathsf{c}=\mathsf{Enc}_{\mathsf{k}}(\mathsf{m}_0)]=\Pr[\mathsf{c}=\mathsf{Enc}_{\mathsf{k}}(\mathsf{m}_1)].\]</span></p>
</div>
<p>Intuitively, the perfect secrecy of the OTP stems from these two
observations:</p>
<ul>
<li><p>Look again at the truth table of the <span class="math inline">\(\mathsf{XOR}\)</span> operation, and
observe that a <span class="math inline">\(0\)</span> in the plaintext could equally come from a <span class="math inline">\(0\)</span> or
a <span class="math inline">\(1\)</span> in the plaintext, depending on the key bit. Similarly, a <span class="math inline">\(1\)</span>
in the ciphertext could also come from a <span class="math inline">\(0\)</span> or a <span class="math inline">\(1\)</span> in the
plaintext. In other words, if the key is chosen uniformly at random,
each bit of the ciphertext has a probability of <span class="math inline">\(1/2\)</span> of coming from
a <span class="math inline">\(0\)</span>, and a probability <span class="math inline">\(1/2\)</span> of coming from a <span class="math inline">\(1\)</span>.</p></li>
<li><p>Because of the above, an adversary that intercepts a ciphertext
<span class="math inline">\(c_1c_2\dots c_\lambda\)</span> cannot know the corresponding plaintext, as
any given plaintext can be encrypted to <em>any</em> bitstring of length
<span class="math inline">\(\lambda\)</span>. In other words, for every ciphertext <span class="math inline">\(\mathsf{c}\)</span> and
every message <span class="math inline">\(\mathsf{m}\)</span>, there exists a key <span class="math inline">\(\mathsf{k}\)</span> and a
message such that
<span class="math display">\[\mathsf{Enc}_{\mathsf{k}}(m)=\mathsf{c}\qquad\text{and}\qquad\mathsf{Dec}_{\mathsf{k}}(\mathsf{c})=m.\]</span>
So any ciphertext could correspond to any message, and there is no
way to do better, regardless of the computational power of the
attacker!</p></li>
</ul>
<p>We formalize the above discussion in the following result.</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-10" class="proposition"><strong>Proposition 2.2  </strong></span><em>The one-time pad encryption scheme has perfect
secrecy.</em></p>
</div>
<div class="proof">
<p><span id="unlabeled-div-11" class="proof"><em>Proof</em>. </span>By the discussion above, we have that for any key <span class="math inline">\(\mathsf{k}\)</span>,
message <span class="math inline">\(\mathsf{m}\)</span> and ciphertext <span class="math inline">\(\mathsf{c}\)</span>,
<span class="math display">\[\Pr[\mathsf{c}=\mathsf{Enc}_{\mathsf{k}}(\mathsf{m})]=\frac{\#\{\text{keys $\mathsf{k}$ such that } \mathsf{c}=\mathsf{Enc}_{\mathsf{k}}(\mathsf{m})\}}{\#\{\text{possible keys}\}}=\frac{1}{2^\lambda}.\]</span></p>
</div>
<div class="exercise">
<p><span id="exr:unlabeled-div-12" class="exercise"><strong>Exercise 2.1  </strong></span><em>We said above that for every message <span class="math inline">\(\mathsf{m}\)</span> and any
ciphertext <span class="math inline">\(\mathsf{c}\)</span>, there is always exactly one key <span class="math inline">\({\mathsf{k}}\)</span>
such that
<span class="math display">\[\mathsf{Enc}_{\mathsf{k}}(m)=\mathsf{c}\qquad\text{and}\qquad\mathsf{Dec}_{\mathsf{k}}(\mathsf{c})=m.\]</span>
For arbitrary <span class="math inline">\(\mathsf{m}\)</span> and <span class="math inline">\(\mathsf{c}\)</span>, which is that key,
expressed in terms of <span class="math inline">\(\mathsf{m}\)</span> and <span class="math inline">\(\mathsf{c}\)</span>?</em></p>
</div>
<p>This is all well and good, but obviously thereâs a catch. While the
security of one-time pad is as good as it gets, it is simply impractical
for a very simple reason: we need a key as large as the message, and
moreover, we need a new key for each message. Moreover, if we want
perfect secrecy, this is unavoidable.</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-13" class="proposition"><strong>Proposition 2.3  </strong></span><em>Any encryption scheme with perfect secrecy requires a
key that is as long as the message, and it cannot be reused.</em></p>
</div>
<p>One reason that highlights how reusing keys in OTP breaks perfect
secrecy is the following. Assume that we use the same key <span class="math inline">\(\mathsf{k}\)</span>
for two messages <span class="math inline">\(\mathsf{m}_0,\mathsf{m}_1\)</span>. Then, an attacker
intercepts the ciphertexts
<span class="math display">\[\mathsf{c}_0=\mathsf{m}_0\oplus\mathsf{k}, \qquad \mathsf{c}_1=\mathsf{m}_1\oplus\mathsf{k}.\]</span>
The adversary can compute
<span class="math display">\[\mathsf{c}_0\oplus\mathsf{c}_1=(\mathsf{m}_0\oplus\mathsf{k})\oplus (\mathsf{m}_1\oplus\mathsf{k})= \mathsf{m}_0\oplus\mathsf{m}_1\oplus(\mathsf{k}\oplus\mathsf{k})=\mathsf{m}_0\oplus\mathsf{m}_1\oplus\mathbf 0=\mathsf{m}_0\oplus m_1.\]</span>
That is, the adversary can get the <span class="math inline">\(\mathsf{XOR}\)</span> result of the two
messages. Even if they do not know any of the messages on their own,
this leaks partial information (e.g.Â a <span class="math inline">\(0\)</span> in any position means that
the two messages have the same value on that position).</p>
<p>So itâs clear that for OTP to work we need keys as long as the messages,
and there is no way around that. But how much of a big deal is that? An
issue that we have not addressed yet is the fact that, for any of this
to happen, the two parties involved need to agree on a common key
<span class="math inline">\({\mathsf{k}}\)</span>, that must remain secret for anyone else. If an insecure
channel is the only medium for communication available:</p>
<ul>
<li><p>they cannot share the key unencrypted, since an attacker could be
listening, and grab the key to decrypt everything that comes
afterwards.</p></li>
<li><p>they cannot encrypt the key, since they donât have a shared key to
use encryption yet!</p></li>
</ul>
<p>Later in the course, we will see that there are ways to securely share a
key over an insecure channel. But for now, it suffices to say that these
methods exist. However, sharing a new key of the size of the message,
and a new one for each message, is simply not practical most of the
time. Imagine the key sizes for sending audio or video over the
Internet. This, ultimately, is what kills the one-time pad.</p>
</div>
<div id="sec:prngs" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Pseudorandom generators</h2>
<p>Before we move on, let us see if there is still some hope for the
one-time pad. What if we start from a short uniformly random key
<span class="math inline">\(\mathsf{k}\)</span>, and try to expand it to a longer key?</p>
<p>Let us assume that Alice and Bob wish to communicate using the one-time
pad, and Alice wants to send a message of length <span class="math inline">\(h\)</span>. But they have only
shared a key <span class="math inline">\({\mathsf{k}}\in\{0,1\}^\ell\)</span>, for some <span class="math inline">\(\ell&lt;h\)</span>, so they
proceed as follows:</p>
<ol style="list-style-type: decimal">
<li><p>They agree on a public function
<span class="math display">\[G:\{0,1\}^\ell\rightarrow\{0,1\}^{h}.\]</span> That is, <span class="math inline">\(G\)</span> receives a
bitstring of length <span class="math inline">\(\ell\)</span> and outputs another of length <span class="math inline">\(h\)</span>.</p></li>
<li><p>Since the function is deterministic, they can both compute
<span class="math display">\[{\mathsf{k}}&#39;=G({\mathsf{k}})\]</span> on their own. Now they both know
<span class="math inline">\({\mathsf{k}}&#39;\in\{0,1\}^{h}\)</span>.</p></li>
<li><p>They use the one-time pad with key <span class="math inline">\({\mathsf{k}}&#39;\)</span>.</p></li>
</ol>
<p>Observe that, since they have already âstretchedâ the key once, they
could potentially take parts of <span class="math inline">\(\mathsf{k}&#39;\)</span> and apply the function <span class="math inline">\(G\)</span>
again to generate new keys on demand. The scheme that results from
stretching the randomness of a short shared key to an arbitrary length
and encrypt the message through the <span class="math inline">\(\mathsf{XOR}\)</span> operation is known as
a <em>stream cipher</em>. The initial key used is called the <em>seed</em>, and the
subsequent keys generated are called the <em>key stream</em>.</p>
<p>The function <span class="math inline">\(G\)</span> must be deterministic, otherwise Alice and Bob will not
arrive at the same key, and they will not be able to communicate. Also
note that, although <span class="math inline">\(G\)</span> is public, <span class="math inline">\({\mathsf{k}}\)</span> is not, so an attacker
has no way of learning the new key <span class="math inline">\({\mathsf{k}}&#39;\)</span>.</p>
<p>However, there are some caveats to this. Since the input of the function
is a set of size <span class="math inline">\(2^\ell\)</span>, there are at most <span class="math inline">\(2^\ell\)</span> outputs, whereas
if we had used a uniformly random key of length <span class="math inline">\(h\)</span>, we would have
<span class="math inline">\(2^{h}\)</span> potential keys. Recall that perfect secrecy strongly relied on
the keys being uniformly random, which clearly will not be the case
here.</p>
<p>But, what if the output of <span class="math inline">\(G\)</span> looks âclose enoughâ to random? By this,
we mean that no efficient algorithm can distinguish the output
distribution of <span class="math inline">\(G\)</span> and the uniform distribution in <span class="math inline">\(\{0,1\}^{h}\)</span>. Then,
if an adversary cannot tell that we are using a non-uniform
distribution, they will not be able to exploit this fact in their
attacks, and so our scheme will remain secure. Is any function <span class="math inline">\(G\)</span> good
enough for our purposes?</p>
<div class="exercise">
<p><span id="exr:unlabeled-div-14" class="exercise"><strong>Exercise 2.2  </strong></span><em>Consider the stream cipher presented above, with the
following choices for the function <span class="math inline">\(G\)</span>, for <span class="math inline">\(h=2\ell\)</span>.</em></p>
<ol style="list-style-type: decimal">
<li><p><em><span class="math inline">\(G\)</span> outputs a string of <span class="math inline">\(2\ell\)</span> zeroes.</em></p></li>
<li><p><em><span class="math inline">\(G\)</span> outputs the input, followed by a string of <span class="math inline">\(\ell\)</span> zeroes.</em></p></li>
<li><p><em><span class="math inline">\(G\)</span> outputs two concatenated copies of the input.</em></p></li>
</ol>
<p><em>In each of these cases, discuss whether the scheme is still secure.</em></p>
</div>
<p>The above exercise shows that we need to be careful when choosing our
function <span class="math inline">\(G\)</span>. This leads us to the following definition.</p>
<div class="definition">
<p><span id="def:unlabeled-div-15" class="definition"><strong>Definition 2.2  </strong></span><em>A</em> pseudorandom number generator (PRNG) <em>is a
function <span class="math display">\[G:\{0,1\}^\ell\rightarrow\{0,1\}^h\]</span>such that no efficient
adversary can distinguish the output distribution of <span class="math inline">\(G\)</span> from the
uniform distribution on</em> <span class="math inline">\(\{0,1\}^h\)</span>.</p>
</div>
<p>We emphasize the importance of randomness here. A function <span class="math inline">\(G\)</span> whose
output cannot be distinguished from uniform randomness by any
(efficient) algorithm implies that, for all practical purposes, the
output of <span class="math inline">\(G\)</span> can be considered uniformly random in <span class="math inline">\(\{0,1\}^h\)</span>. In
particular, informally this means that a key stream generated with a
PRNG is <em>unpredictable</em>, i.e., given some output bits of <span class="math inline">\(G\)</span>, there is
no way to predict the next in polynomial time, with a success rate
higher than <span class="math inline">\(50\%\)</span>. This contrasts with non-cryptographic PRNGs, in
which it is enough that the output passes some statistical tests, but
might not be completely unpredictable.</p>
<div class="exercise">
<p><span id="exr:unlabeled-div-16" class="exercise"><strong>Exercise 2.3  </strong></span><em>Assume that there is a very bad PRNG that outputs one
bit at a time, and that bit is a <span class="math inline">\(0\)</span> with probability <span class="math inline">\(3/4\)</span>. This PRNG is
used in a stream cipher to produce a ciphertext <span class="math display">\[c=01.\]</span> In OTP, the
probability of the corresponding plaintext being <span class="math inline">\(00\)</span>, <span class="math inline">\(01\)</span>, <span class="math inline">\(10\)</span> or
<span class="math inline">\(11\)</span> would be <span class="math inline">\(1/4\)</span> each. Compute the corresponding probabilities when
the bad PRNG described above is in use.</em></p>
</div>
<p>An interesting property of PRNGs is that, if we manage to build one that
stretches the key by just a little, then we can produce an infinitely
large key stream, and still maintain essentially the same security
guarantees. To illustrate this, let us again consider a function
<span class="math display">\[G:\{0,1\}^\ell\rightarrow\{0,1\}^{2\ell},\]</span> and let us assume that it
is a PRNG.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> Consider the following construction of a new function
<span class="math display">\[H:\{0,1\}^\ell\rightarrow\{0,1\}^{3\ell},\]</span> which works as follows: on
input <span class="math inline">\({\mathsf{k}}\)</span>,</p>
<ol style="list-style-type: decimal">
<li><p>First compute <span class="math inline">\(G({\mathsf{k}})\in\{0,1\}^{2\ell}\)</span>.</p></li>
<li><p>Split the result in two halves <span class="math inline">\(\mathbf{x},\mathbf{y}\)</span>, each of
length <span class="math inline">\(\ell\)</span>.</p></li>
<li><p>Compute <span class="math inline">\(\mathbf{z}=G(\mathbf{y})\in\{0,1\}^{2\ell}\)</span>.</p></li>
<li><p>Output <span class="math inline">\((\mathbf{x},\mathbf{z})\in\{0,1\}^{3\ell}\)</span>.</p></li>
</ol>
<div class="proposition">
<p><span id="prp:unlabeled-div-17" class="proposition"><strong>Proposition 2.4  </strong></span><em>If <span class="math inline">\(G\)</span> is a PRNG, then <span class="math inline">\(H\)</span>, constructed as described
above, is also a PRNG.</em></p>
</div>
<p>We have already seen some bad PRNGs, so what about the good ones?
Although there exist some proposals of PRNGs that are believed to be
secure and are built âfrom scratchâ, what happens in practice is that,
when one wants a PRNG, it is common to build it from a block cipher,
which is a topic that we will cover later in the course, so we delay the
examples of cryptographic PRNGs until then. For completeness, we next look at a function that is enough for most applications of pseudorandom generation, but is not secure for
cryptographic use.</p>
</div>
<div id="sec:examples" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Linear feedback shift registers</h2>
<p>A <em>linear feedback shift register</em> is a type of âstretching functionâ
that produces an output that looks quite random, and it passes some
statistical tests, although it is still weak from a cryptographic point
of view. We will start with a particular example. Assume that we have a
seed <span class="math inline">\(k\)</span>, written as a bitstring <span class="math inline">\({\mathsf{k}}=k_1k_2k_3\)</span>. The linear
feedback shift register recursively produces each new element of the key
according to the formula: <span class="math display">\[k_{i+3}=k_{i+1}\oplus k_i.\]</span> For example, if
the seed is <span class="math inline">\(011\)</span>, the key stream will be
<span class="math display">\[0111001\quad 0111001\quad 0111001\quad 0111001\quad 0111001 \quad \dots\]</span>
We included the spaces to emphasize the fact that, after a while, the
output seems to repeat. This is not something specific to this example,
but actually happens to any linear feedback shift register.</p>
<p>Indeed, let us define a general <em>linear feedback shift register (LFSR)
of length <span class="math inline">\(\ell\)</span></em>. It starts with a seed <span class="math inline">\({\mathsf{k}}\)</span>, expressed as a
bitstring <span class="math display">\[{\mathsf{k}}=k_1k_2\dots k_\ell,\]</span> and derives each new
element of the key stream according to the following: for <span class="math display">\[i&gt;\ell\]</span>:
<span class="math display">\[k_{i}=p_{1}k_{i-1}\oplus \dots \oplus p_\ell k_{i-\ell},\]</span> for some
coefficients <span class="math inline">\(p_j\in\{0,1\}\)</span>, for <span class="math inline">\(j=1,\dots,\ell\)</span>.</p>
<div class="proposition">
<p><span id="prp:unlabeled-div-18" class="proposition"><strong>Proposition 2.5  </strong></span><em>The output of an LFSR of length <span class="math inline">\(\ell\)</span> repeats
periodically, with a period of at most <span class="math inline">\(2^{\ell}-1\)</span>.</em></p>
</div>
<p>Note the âat mostâ in the statement. For some choices of the
coefficients <span class="math inline">\(p_j\)</span>, the period could be much shorter. However, for
well-chosen coefficients, we can meet the bound, thus obtaining a period
that is exponential in the length of the initial key. The output of a
well-chosen LFSR has some good statistical properties. In particular,
the output looks ârandom enoughâ for most applications. However, there
are attacks that allow an adversary to distinguish the output from
uniformly random, and thus LFSRs are not suited for cryptography.</p>
<p>Still, a clever combination of a few LFSRs, with a couple of extra
details, seems to be enough to realize the stream cipher Trivium, which,
to this date, is believed to be secure.</p>
<p>Below is a direct implementation of an LFSR. You can try different sets of feedback coeffients, and see how this impacts the period of the key stream.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="randomness-in-cryptography.html#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the XOR operation:</span></span>
<span id="cb3-2"><a href="randomness-in-cryptography.html#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> xor(a,b):</span>
<span id="cb3-3"><a href="randomness-in-cryptography.html#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mod(<span class="bu">int</span>(a)<span class="op">+</span><span class="bu">int</span>(b),<span class="dv">2</span>)</span>
<span id="cb3-4"><a href="randomness-in-cryptography.html#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="randomness-in-cryptography.html#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Set a vector of feedback coefficients [p_1, ... , p_n]</span></span>
<span id="cb3-6"><a href="randomness-in-cryptography.html#cb3-6" aria-hidden="true" tabindex="-1"></a>feedback_coeffs <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb3-7"><a href="randomness-in-cryptography.html#cb3-7" aria-hidden="true" tabindex="-1"></a>seed_length <span class="op">=</span> <span class="bu">len</span>(feedback_coeffs)</span>
<span id="cb3-8"><a href="randomness-in-cryptography.html#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="randomness-in-cryptography.html#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Sample a uniformly random seed of the same length.</span></span>
<span id="cb3-10"><a href="randomness-in-cryptography.html#cb3-10" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="bu">list</span>(random_vector(GF(<span class="dv">2</span>),seed_length))</span>
<span id="cb3-11"><a href="randomness-in-cryptography.html#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(seed)</span>
<span id="cb3-12"><a href="randomness-in-cryptography.html#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="randomness-in-cryptography.html#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose the length of the required key stream</span></span>
<span id="cb3-14"><a href="randomness-in-cryptography.html#cb3-14" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb3-15"><a href="randomness-in-cryptography.html#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="randomness-in-cryptography.html#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the LFSR</span></span>
<span id="cb3-17"><a href="randomness-in-cryptography.html#cb3-17" aria-hidden="true" tabindex="-1"></a>key_stream<span class="op">=</span>seed</span>
<span id="cb3-18"><a href="randomness-in-cryptography.html#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(seed_length,seed_length<span class="op">+</span>k):</span>
<span id="cb3-19"><a href="randomness-in-cryptography.html#cb3-19" aria-hidden="true" tabindex="-1"></a>    key_stream_temp<span class="op">=</span><span class="dv">0</span></span>
<span id="cb3-20"><a href="randomness-in-cryptography.html#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(seed_length):</span>
<span id="cb3-21"><a href="randomness-in-cryptography.html#cb3-21" aria-hidden="true" tabindex="-1"></a>        key_stream_temp <span class="op">=</span> xor(key_stream_temp,(feedback_coeffs[j]<span class="op">*</span>key_stream[i<span class="op">-</span>j<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb3-22"><a href="randomness-in-cryptography.html#cb3-22" aria-hidden="true" tabindex="-1"></a>    key_stream.append(key_stream_temp)</span>
<span id="cb3-23"><a href="randomness-in-cryptography.html#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(key_stream)</span></code></pre></div>
</div>
<div id="true-randomness" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> True randomness</h2>
<p>We have dealt with the problem of stretching a tiny bit of randomness
into something usable. But where does this initial randomness come from?
It cannot really come from our computers, since these are deterministic,
so the answer lies out in the physical world.<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> The general idea is to
look for unpredictable processes from which to extract randomness. Some
examples are radioactive decay, cosmic radiation, hardware processes
like the least significant bit of the timestamp of a keystroke.</p>
<p>These processes might not produce uniformly random outputs, but from our
perspective we have little to none information about their output
distribution. These values are not used raw, but processed by a <em>random
number generator (RNG)</em>, which refines them into what we assume to be
uniformly random outputs. These can now be fed into our PRNGs to stretch
them.</p>

</div>
</div>
<div class="footnotes">
<hr />
<ol start="7">
<li id="fn7"><p>If the message is written with a different set of characters, like
English letters, it is first processed into a bitstring, e.g.Â by
associating to each letter its ASCII code in binary
(<a href="https://en.wikipedia.org/wiki/ASCII" class="uri">https://en.wikipedia.org/wiki/ASCII</a>).<a href="randomness-in-cryptography.html#fnref7" class="footnote-back">â©ï¸</a></p></li>
<li id="fn8"><p>We set the output length to be <span class="math inline">\(2\ell\)</span> for simplicity, but the
idea could easily be adapted to any other output length.<a href="randomness-in-cryptography.html#fnref8" class="footnote-back">â©ï¸</a></p></li>
<li id="fn9"><p>Assuming, of course, that the universe is not completely
deterministic.<a href="randomness-in-cryptography.html#fnref9" class="footnote-back">â©ï¸</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="introduction-to-security.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="block-ciphers.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
