<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 Introduction to Security | Cryptography lecture notes</title>
  <meta name="description" content="1 Introduction to Security | Cryptography lecture notes" />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="1 Introduction to Security | Cryptography lecture notes" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 Introduction to Security | Cryptography lecture notes" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="randomness-in-cryptography.html"/>
<script src="libs/header-attrs-2.6/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="part"><span><b>I Introduction to modern cryptography</b></span></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Front page</a></li>
<li class="chapter" data-level="1" data-path="introduction-to-security.html"><a href="introduction-to-security.html"><i class="fa fa-check"></i><b>1</b> Introduction to Security</a>
<ul>
<li class="chapter" data-level="1.1" data-path="introduction-to-security.html"><a href="introduction-to-security.html#what-cryptography-is-and-is-not"><i class="fa fa-check"></i><b>1.1</b> What cryptography is and is not</a></li>
<li class="chapter" data-level="1.2" data-path="introduction-to-security.html"><a href="introduction-to-security.html#fundamental-security-principles"><i class="fa fa-check"></i><b>1.2</b> Fundamental security principles</a></li>
<li class="chapter" data-level="1.3" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-parameter"><i class="fa fa-check"></i><b>1.3</b> Security parameter</a></li>
<li class="chapter" data-level="1.4" data-path="introduction-to-security.html"><a href="introduction-to-security.html#security-level"><i class="fa fa-check"></i><b>1.4</b> Security level</a></li>
</ul></li>
<li class="part"><span><b>II Symmetric cryptography</b></span></li>
<li class="chapter" data-level="2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html"><i class="fa fa-check"></i><b>2</b> Randomness in cryptography</a>
<ul>
<li class="chapter" data-level="2.1" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#one-time-pad"><i class="fa fa-check"></i><b>2.1</b> One-time pad</a></li>
<li class="chapter" data-level="2.2" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:prngs"><i class="fa fa-check"></i><b>2.2</b> Pseudorandom generators</a></li>
<li class="chapter" data-level="2.3" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#sec:examples"><i class="fa fa-check"></i><b>2.3</b> Linear feedback shift registers</a></li>
<li class="chapter" data-level="2.4" data-path="randomness-in-cryptography.html"><a href="randomness-in-cryptography.html#true-randomness"><i class="fa fa-check"></i><b>2.4</b> True randomness</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="block-ciphers.html"><a href="block-ciphers.html"><i class="fa fa-check"></i><b>3</b> Block ciphers</a></li>
<li class="chapter" data-level="4" data-path="hash-functions.html"><a href="hash-functions.html"><i class="fa fa-check"></i><b>4</b> Hash functions</a></li>
<li class="part"><span><b>III Asymmetric cryptography</b></span></li>
<li class="chapter" data-level="5" data-path="number-theory.html"><a href="number-theory.html"><i class="fa fa-check"></i><b>5</b> Elementary number theory</a></li>
<li class="chapter" data-level="6" data-path="algebraic-structures.html"><a href="algebraic-structures.html"><i class="fa fa-check"></i><b>6</b> Algebraic structures</a></li>
<li class="chapter" data-level="7" data-path="pke.html"><a href="pke.html"><i class="fa fa-check"></i><b>7</b> Public-key encryption</a></li>
<li class="chapter" data-level="8" data-path="dh.html"><a href="dh.html"><i class="fa fa-check"></i><b>8</b> The Diffie–Hellman key exchange</a></li>
<li class="chapter" data-level="9" data-path="signatures.html"><a href="signatures.html"><i class="fa fa-check"></i><b>9</b> Digital signatures</a></li>
<li class="part"><span><b>IV Other topics</b></span></li>
<li class="chapter" data-level="10" data-path="cryptanalysis.html"><a href="cryptanalysis.html"><i class="fa fa-check"></i><b>10</b> Cryptanalysis</a></li>
<li class="appendix"><span><b>Appendices</b></span></li>
<li class="chapter" data-level="A" data-path="set-theory.html"><a href="set-theory.html"><i class="fa fa-check"></i><b>A</b> Set theory</a></li>
<li class="chapter" data-level="B" data-path="introduction-to-sage.html"><a href="introduction-to-sage.html"><i class="fa fa-check"></i><b>B</b> Introduction to Sage</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Cryptography lecture notes</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="introduction-to-security" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction to Security</h1>
<p>We use cryptography on a daily basis: our wireless communications or web
traffic are encrypted, companies protect their data with cryptographic
algorithms, and so on. We all have a basic or intuitive understanding of
how cryptographic algorithms work. In this chapter, we want to make this
intuition more precise and give you tools to think about cryptographic
algorithms more formally, and reason scientifically about security.</p>
<p>Therefore, in this section we will:</p>
<ol style="list-style-type: decimal">
<li><p>Introduce three basic principles of cryptographic algorithm design;</p></li>
<li><p>Introduce the notion of security parameter and security level.</p></li>
</ol>
<div id="what-cryptography-is-and-is-not" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> What cryptography is and is not</h2>
<p>Cryptography is a field that lies halfway between mathematics and
computer science, and is occupied with building algorithms that protect
communications in some way, for example ensuring privacy or integrity of
a message sent through an insecure channel.</p>
<p>In this course, we will describe some of the most important
cryptographic algorithms. They are the foundation for many security
mechanisms and protocols that are part of the digital world. Thus, when
you finish this course, you will have the basis to understand these
mechanisms. But it is also important that you understand what is <em>not</em>
covered in this course, and what are the limitations of what you will
learn. In particular, a well-known course on cryptography<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> mentions
three warnings that you should take into consideration:</p>
<ol style="list-style-type: decimal">
<li><p>Cryptography is not the solution to all security problems;</p></li>
<li><p>Cryptography is not reliable unless implemented and used properly;</p></li>
<li><p>Cryptography is not something that you should try to invent
yourself, as there are many and many examples of broken ad-hoc
designs.</p></li>
</ol>
</div>
<div id="fundamental-security-principles" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Fundamental security principles</h2>
<p>Let us consider a common example. When we type our WiFi password to
connect to a network, we are assuming that what we are doing is
"secure" because only us have some secret information (the password),
that allows us to do this. In the context of cryptography, we call this
secret information the <em>secret key</em>.</p>
<p>But what if an attacker tries all the possible keys until he finds the
right one? This is what is called a <em>brute-force attack</em>. We will
consider a few different scenarios:</p>
<ul>
<li><p>Our secret key is a 4-digit number. Then, in the worst case, the
attacker will need to try <span class="math display">\[10^4=10000\]</span> potential keys. Assuming
one try per second, this will take a bit less than three hours.</p></li>
<li><p>Our secret key is a 12-character string of digits and English
letters. Since there are 10 possible digits and 26 possible letters
for each position, the number of potential keys is
<span class="math display">\[36^{12}=4738381338321616896.\]</span> At the same rate, the attacker will
need, approximately, <span class="math inline">\(1.5\cdot10^{11}\)</span> <em>years</em> to try all of them.
For reference, this number is roughly half of the number of stars in
the Milky Way.</p></li>
</ul>
<div class="exercise">
<p><span id="exr:unlabeled-div-1" class="exercise"><strong>Exercise 1.1  </strong></span><em>A WiFi password is <span class="math inline">\(10\)</span> bits long. How long does it
take to find the key by brute force? What if the password is <span class="math inline">\(\lambda\)</span>
bits long?</em></p>
</div>
<p>The idea is that, if our password is generated in a good way, this will
take too long! So we are implicitly thinking that our scheme is secure
because an attacker has limited time or limited money to buy hardware to
perform very fast attacks and find our password. This leads to the first
fundamental principle of modern cryptography:</p>
<div id="principle:1" class="principle">
<p><strong>Principle 1</strong>. <em>Security depends on the resources of the attacker. We
say that a cryptographic scheme is secure if there are no efficient
attacks.</em></p>
</div>
<p>Cryptographic algorithms need to be carefully reviewed by the scientific
community, and directions for implementation and interoperability must
be given before they are adopted. This is done by institutions such as
NIST, the National Institute of Standards and Technology in the US.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>
Thus, coming up with new, secure algorithms is difficult. In fact, the
algorithms that are used in practice are public, known to everyone, and
in particular to potential attackers. For instance, in the case of a
WiFi password, it is a publicly-known fact that WPA is used. This is a
general design principle in cryptography: security must come from the
choice of a secret key and not from attackers not knowing which
algorithm we are using.</p>
<div id="principle:2" class="principle">
<p><strong>Principle 2</strong> (Kerckhoffs’s principle). <em>Design your system so that it
is secure even if the attacker knows all of its algorithms.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></em></p>
</div>
<p>So what makes our systems secure is the fact that, although the attacker
knows the algorithm, it does not know the secret key that we are using.
Back to the WiFi example, an attacker knows that the WPA standard is
used, but they just don’t know our password.</p>
<p>Another implicit assumption that we are making when we think that our
connection is "secure" is that our secret key is <em>sufficiently random</em>,
that is, that there are <em>many possibilities</em> for the secret key. This
leads us to the third and last principle.</p>
<div id="principle:3" class="principle">
<p><strong>Principle 3</strong>. <em>Security is impossible without randomness.</em></p>
</div>
<p>As we will see, randomness plays an essential role in cryptographic
algorithms. In particular, it is always essential that secret keys are
chosen to be sufficiently random (i.e. they should have enough entropy).
A bad randomness source almost always translates into a weakness of the
cryptographic algorithm.</p>
</div>
<div id="security-parameter" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Security parameter</h2>
<p>Obviously, cryptographic algorithms need to be efficient to be used in
practice. On the other hand, we have seen that no attack should be
efficient at all, i.e. they should be <em>computationally infeasible</em>.
Before we go on, we need to determine the meaning of efficiency, so that
the concept is formal and quantifiable. At the same time, and because of
<a href="introduction-to-security.html#principle:1" reference-type="ref" reference="principle:1">Principle 1</a>, we need to relate efficiency with security
somehow.</p>
<p>The way to achieve this is through a natural number that we call the
<em>security parameter</em>, usually denoted by <span class="math inline">\(\lambda\)</span>. The information
about both security and efficiency will be expressed in terms of the
security parameter.</p>

<div class="definition">
<span id="def:efficiency" class="definition"><strong>Definition 1.1  </strong></span><em>An algorithm <span class="math inline">\(\mathcal{A}\)</span> is said to be</em> efficient <em>(or</em> polynomial-time <em>if there exists a positive polynomial <span class="math inline">\(p\)</span> such
that, for any <span class="math inline">\(\lambda\in\mathbb{N}\)</span>, when <span class="math inline">\(\mathcal{A}\)</span> receives as
input a bitstring of length <span class="math inline">\(\lambda\)</span>, it finishes in <span class="math inline">\(p(\lambda)\)</span>
steps.</em>
</div>
<p>We note that here we are interested in having a rough estimate on the
running time, so we count each basic bit operation as one step. We use
equivalently the terms <em>running time</em>, <em>number of steps</em>, <em>number of
operations</em>.</p>
<p>An important observation is that a <em>single polynomial</em> must work for any
value of <span class="math inline">\(\lambda\)</span>. Otherwise, any algorithm would be considered
efficient. The intuition behind the definition is that we allow the
running time of the algorithm to grow when the input gets larger, but
not “too much too fast.” Let us consider two examples to illustrate the
concept of polynomial-time algorithms:</p>
<ul>
<li><p>Algorithm <span class="math inline">\(\mathcal{A}\)</span> takes two <span class="math inline">\(\lambda\)</span>-bit integers <span class="math inline">\(m,n\)</span> and
adds them.</p></li>
<li><p>Algorithm <span class="math inline">\(\mathcal{B}\)</span> takes a <span class="math inline">\(\lambda\)</span>-bit integer
<span class="math inline">\(n\in\{0,\dots,2^{\lambda}-1\}\)</span> and finds its prime factors in the
following way: for each <span class="math inline">\(i=1,\dots,n\)</span>, it checks whether <span class="math inline">\(i\)</span> divides
<span class="math inline">\(n\)</span>, and if that is the case it outputs <span class="math inline">\(i\)</span>.</p></li>
</ul>
<p>Are they efficient? The first one is efficient, because the number of
operations is <span class="math inline">\(O(\lambda)\)</span>, while the second one is inefficient because
the number of operations is <span class="math inline">\(O(2^{\lambda})\)</span>. In other words, the number
of operations grows <em>exponentially</em> when we increase the size of the
input. As is well known, exponential functions grow much faster than
polynomials, and so in this case we will not be able to find a
polynomial to satisfy Definition <a href="introduction-to-security.html#def:efficiency">1.1</a>. Thus, algorithm <span class="math inline">\(\mathcal{B}\)</span> is not
efficient.</p>
<p>Below, you can find a Sage implementation of each of the two algorithms,
with the tools to compare their running times for different sizes of
<span class="math inline">\(\lambda\)</span>. Observe that, by increasing the security parameter, soon the
second algorithm starts taking too long to terminate.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="introduction-to-security.html#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose the security parameter</span></span>
<span id="cb1-2"><a href="introduction-to-security.html#cb1-2" aria-hidden="true" tabindex="-1"></a>sec_param <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb1-3"><a href="introduction-to-security.html#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="introduction-to-security.html#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate two random numbers of bit length lambda</span></span>
<span id="cb1-5"><a href="introduction-to-security.html#cb1-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> randrange(<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">-</span><span class="dv">1</span>),<span class="dv">2</span><span class="op">^</span>(sec_param)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-6"><a href="introduction-to-security.html#cb1-6" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> randrange(<span class="dv">2</span><span class="op">^</span>(sec_param<span class="op">-</span><span class="dv">1</span>),<span class="dv">2</span><span class="op">^</span>(sec_param)<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb1-7"><a href="introduction-to-security.html#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="introduction-to-security.html#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">&quot;n =&quot;</span>,n,<span class="st">&quot;</span><span class="ch">\n</span><span class="st">m =&quot;</span>,m)</span>
<span id="cb1-9"><a href="introduction-to-security.html#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="introduction-to-security.html#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Define algorithm A, which adds the two numbers</span></span>
<span id="cb1-11"><a href="introduction-to-security.html#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> algorithm_a(n,m):</span>
<span id="cb1-12"><a href="introduction-to-security.html#cb1-12" aria-hidden="true" tabindex="-1"></a>    n<span class="op">+</span>m</span>
<span id="cb1-13"><a href="introduction-to-security.html#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="introduction-to-security.html#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Measure the time it takes to run algorithm A</span></span>
<span id="cb1-15"><a href="introduction-to-security.html#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time algorithm_a(n,m)</span>
<span id="cb1-16"><a href="introduction-to-security.html#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="introduction-to-security.html#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Define algorithm A, which tries to factor a number</span></span>
<span id="cb1-18"><a href="introduction-to-security.html#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> algorithm_b(n):</span>
<span id="cb1-19"><a href="introduction-to-security.html#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb1-20"><a href="introduction-to-security.html#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> mod(n,i)<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb1-21"><a href="introduction-to-security.html#cb1-21" aria-hidden="true" tabindex="-1"></a>            i</span>
<span id="cb1-22"><a href="introduction-to-security.html#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="introduction-to-security.html#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Measure the time it takes to run algorithm B</span></span>
<span id="cb1-24"><a href="introduction-to-security.html#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>time algorithm_b(n)</span></code></pre></div>
<div class="exercise">
<p><span id="exr:unlabeled-div-3" class="exercise"><strong>Exercise 1.2  </strong></span><em>Decide whether the following algorithms run in
polynomial time:</em></p>
<ul>
<li><p><em>An algorithm that takes as input two integers <span class="math inline">\(n,m\)</span> (in base 2) and
computes the sum <span class="math inline">\(n+m\)</span>.</em></p></li>
<li><p><em>An algorithm that takes as input an integer <span class="math inline">\(n\)</span> and prints all the
integers from <span class="math inline">\(1\)</span> to <span class="math inline">\(\ell\)</span>, if:</em></p>
<ul>
<li><p><em><span class="math inline">\(\ell=n\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(\ell=n/2\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(\ell=\sqrt{n}\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(\ell=10^6\)</span>.</em></p></li>
<li><p><em><span class="math inline">\(\ell=\log_2 n\)</span>.</em></p></li>
</ul></li>
</ul>
</div>
<p>We are now in position to discuss the efficiency and security of a
cryptographic scheme in more grounded terms. For cryptographic schemes
that require secret keys, the security parameter <span class="math inline">\(\lambda\)</span> is the bit
length of the key. All the algorithms that compose some cryptographic
scheme, like an encryption or signature scheme, should run in time
polynomial in <span class="math inline">\(\lambda\)</span>.</p>
<p>A classical example of this is an encryption scheme, which is the
cryptographic primitive that will be the focus of most of the course. We
first introduce the notion of symmetric encryption scheme.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>

<div class="definition">
<p><span id="def:unnamed-chunk-2" class="definition"><strong>Definition 1.2  </strong></span><em>A</em> symmetric encryption scheme <em>is composed of three
efficient algorithms:</em> <span class="math display">\[(\mathsf{KeyGen},\mathsf{Enc},\mathsf{Dec}).\]</span></p>
<ul>
<li><p><em>The <span class="math inline">\(\mathsf{KeyGen}\)</span> algorithm chooses some key <span class="math inline">\(\mathsf{k}\)</span> of
length <span class="math inline">\(\lambda\)</span>, according to some probability distribution.</em></p></li>
<li><p><em>The <span class="math inline">\(\mathsf{Enc}\)</span> algorithm uses the secret key <span class="math inline">\(\mathsf{k}\)</span> to
encrypt a message <span class="math inline">\(\mathsf{m}\)</span>, and outputs the encrypted message
<span class="math display">\[\mathsf{c}=\mathsf{Enc}_{\mathsf{k}}(\mathsf{m}).\]</span></em></p></li>
<li><p><em>The <span class="math inline">\(\mathsf{Dec}\)</span> algorithm uses the secret key <span class="math inline">\(\mathsf{k}\)</span> to
decrypt an encrypted message <span class="math inline">\(\mathsf{c}\)</span>, recovering
<span class="math display">\[\mathsf{Dec}_{\mathsf{k}}(\mathsf{c})=\mathsf{m}.\]</span></em></p></li>
</ul>
<em>In this context, <span class="math inline">\(\mathsf{m}\)</span> is called the </em>plaintext<em>, and
<span class="math inline">\(\mathsf{c}\)</span> is said to be its corresponding </em>ciphertext<em>.</em>
</div>
<p>Technically, the fact that the algorithms are efficient is expressed as
requiring that the three algorithms run in time polynomial in
<span class="math inline">\(\lambda\)</span>.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<p>On the other hand, observe that, if an attacker wants to try all the
possible secret keys, it needs <span class="math inline">\(O(2^{\lambda})\)</span> steps to do so. This is
not polynomial time in the security parameter (again, it is
exponential), so it is not efficient according to
Definition <a href="introduction-to-security.html#def:efficiency">1.1</a>.</p>
</div>
<div id="security-level" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Security level</h2>
<p>Ideally, we would like that the best possible attack against a scheme is
a brute-force attack, in which an attacker (also called <em>adversary</em>)
needs to try all the possibilities. However, very often there exist much
more sophisticated attacks that need less time. This motivates the
following definition:</p>

<div class="definition">
<span id="def:unnamed-chunk-3" class="definition"><strong>Definition 1.3  </strong></span><em>A cryptographic scheme has</em> <span class="math inline">\(n\)</span>-bit security <em>if the
best known attack requires <span class="math inline">\(2^{n}\)</span> steps.</em>
</div>
<p>When the best known attack is a brute-force attack, then <span class="math inline">\(n=\lambda\)</span>,
but we will see many examples of the opposite, which makes <span class="math inline">\(n\)</span>
significantly smaller. In a few lessons, we will see the example of hash
functions, for which, in the best case, <span class="math display">\[n=\frac\lambda 2.\]</span> If we
require a security level of <span class="math inline">\(80\)</span> bits, this forces us to choose
<span class="math inline">\(\lambda=160\)</span>, at the least. Another example is RSA, which is a famous
encryption scheme that we will study later in the course. In that case,
<span class="math inline">\(\lambda\)</span> needs to be <span class="math inline">\(1024\)</span> to achieve a security level of roughly <span class="math inline">\(80\)</span>
bits.</p>
<p>Although all the algorithms that compose a scheme, like
<span class="math inline">\((\mathsf{KeyGen},\mathsf{Enc},\mathsf{Dec})\)</span> in the encryption case,
are still efficient, their running time typically increases with
<span class="math inline">\(\lambda\)</span>. The impact of this is that, the higher the value of
<span class="math inline">\(\lambda\)</span>, the more expensive the computations are.</p>
<p>But what is a good security level? Suppose you have some cryptographic
algorithm that has <span class="math inline">\(n\)</span>-bit security for key length <span class="math inline">\(\lambda\)</span>. How do you
decide what <span class="math inline">\(n\)</span> is appropriate for your scheme to be secure? How is <span class="math inline">\(n\)</span>
to be chosen so that it is <em>infeasible</em> (i.e. inefficient for an
adversary) to recover the key?</p>
<p>There is no unique answer to this question. As we saw in
<a href="introduction-to-security.html#principle:1" reference-type="ref" reference="principle:1">Principle 1</a>, security is a matter of resources. If an
adversary needs to use computational power to perform <span class="math inline">\(2^n\)</span> steps to
attack your system, this will cost him money (electric power, hardware,
etc). If your cryptographic tools are protecting something that is worth
only <span class="math inline">\(10\)</span>€, an attacker will not be willing to spend a lot of money
attacking it. RFID tags are a good example of this. On the other hand,
if you are protecting valuable financial information, or critical
infrastructure, you would better make sure that this costs the adversary
a <em>lot</em> of resources.</p>
<p>A general rule of thumb is that a cryptosystem is expected to give you
at the very least an <span class="math inline">\(80\)</span>-bit security level. By today’s computing power
levels, this is considered even a bit weak, and acceptable security
levels are more around the <span class="math inline">\(100\)</span>-bit mark. This does not mean that any
attack below <span class="math inline">\(2^{100}\)</span> can be easily run on your PC at home! The website
<a href="https://www.keylength.com/" class="uri">https://www.keylength.com/</a> maintains a list of key size
recommendations suggested by different organizations.</p>
<p>The following table, taken from Mike Rosulek’s book <em>The Joy of
Cryptography</em> gives some estimates of computational cost in
economic terms.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<div class="center">
<table>
<thead>
<tr class="header">
<th align="left"><span class="smallcaps">Security level</span></th>
<th align="left"><span class="smallcaps">Approximate cost</span></th>
<th align="left"><span class="smallcaps">Reference</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">50</td>
<td align="left">$3.50</td>
<td align="left">cup of coffee</td>
</tr>
<tr class="even">
<td align="left">55</td>
<td align="left">$100</td>
<td align="left">decent tickets to a Portland Trailblazers game</td>
</tr>
<tr class="odd">
<td align="left">65</td>
<td align="left">$130000</td>
<td align="left">median home price in Oshkosh, WI</td>
</tr>
<tr class="even">
<td align="left">75</td>
<td align="left">$130 million</td>
<td align="left">budget of one of the Harry Potter movies</td>
</tr>
<tr class="odd">
<td align="left">85</td>
<td align="left">$140 billion</td>
<td align="left">GDP of Hungary</td>
</tr>
<tr class="even">
<td align="left">92</td>
<td align="left">$20 trillion</td>
<td align="left">GDP of the United States</td>
</tr>
<tr class="odd">
<td align="left">99</td>
<td align="left">$2 quadrillion</td>
<td align="left">all of human economic activity since 300,000 BC</td>
</tr>
<tr class="even">
<td align="left">128</td>
<td align="left">really a lot</td>
<td align="left">a billion human civilizations’ worth of effort</td>
</tr>
</tbody>
</table>
</div>
<div class="exercise">
<p><span id="exr:unlabeled-div-6" class="exercise"><strong>Exercise 1.3  </strong></span><em>Determine the security level when:</em></p>
<ul>
<li><p><em>My password consists of <span class="math inline">\(20\)</span> random letters of the Catalan
alphabet.</em></p></li>
<li><p><em>Same as above, but including also capital letters.</em></p></li>
<li><p><em>My password is a word of the Catalan dictionary (88500 words).</em></p></li>
</ul>
</div>

</div>
</div>



<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>D. Boneh. Cryptography I, Coursera. Available at
<a href="https://www.coursera.org/learn/crypto" class="uri">https://www.coursera.org/learn/crypto</a>.<a href="introduction-to-security.html#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p><a href="https://www.nist.gov/" class="uri">https://www.nist.gov/</a>.<a href="introduction-to-security.html#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p><em>Kerckhoffs’s principle is named after Auguste Kerckhoffs, who
published the article </em>La Cryptographie Militaire* in 1883.*<a href="introduction-to-security.html#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>In the second half of the course, we will deal with the notion of
<em>asymmetric encryption schemes</em>, in which there are two different
keys, a <em>public key</em> that is used for encryption and a <em>secret key</em>
that is used for decryption.<a href="introduction-to-security.html#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>In many cryptography books, you will find that <span class="math inline">\(\mathsf{KeyGen}\)</span>
should be a (probabilistic) polynomial time algorithm that takes as
input <span class="math inline">\(1^{\lambda}\)</span>, which is the string with <span class="math inline">\(\lambda\)</span> ones. This
is a way to write that <span class="math inline">\(\mathsf{KeyGen}\)</span> should be polynomial in
<span class="math inline">\(\lambda\)</span>.<a href="introduction-to-security.html#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Note that he uses the English definition of billion, that is,
<span class="math inline">\(10^9\)</span>. Same for the other amounts. Also, the table seems to be
based on data from 2018, so the up-to-date numbers might vary
slightly.<a href="introduction-to-security.html#fnref6" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="randomness-in-cryptography.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["_main.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
